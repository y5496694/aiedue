<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>📚 에이두 북메이커</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap');
        body { font-family: 'Gowun Dodum', sans-serif; }
        .loader { border: 8px solid #f3f3f3; border-radius: 50%; width: 60px; height: 60px; animation: spin 2s linear infinite; border-top: 8px solid #10b981; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .book-viewer { aspect-ratio: 2 / 1.414; width: 100%; display: flex; }
        .book-page { position: relative; width: 50%; height: 100%; background-size: cover; background-position: center; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 2rem; box-sizing: border-box; }
        .book-spread { display: none; }
        .book-spread.active { display: flex; }
        .text-box { background-color: rgba(255, 255, 255, 0.85); border: 2px solid black; padding: 1rem; text-align: center; }
        .page-nav { position: absolute; top: 50%; transform: translateY(-50%); background-color: rgba(0,0,0,0.5); color: white; border: none; border-radius: 9999px; width: 3rem; height: 3rem; font-size: 2rem; cursor: pointer; z-index: 10; }
        .page-number { position: absolute; bottom: 0.5rem; font-size: 0.875rem; color: #374151; }
        .manual-text-area { width: 100%; height: 80%; background: transparent; border: 2px dashed #ccc; border-radius: 8px; padding: 1rem; text-align: left; overflow-y: auto; font-size: 1.125rem; white-space: pre-wrap; word-break: break-word; }
        .tts-word { cursor: pointer; transition: color 0.2s; }
        .tts-word:hover { color: #3b82f6; }
        .character-image-box { position: relative; overflow: hidden; }
        .image-action-btn { position: absolute; top: 0.5rem; right: 0.5rem; background-color: rgba(17, 24, 39, 0.85); color: white; font-size: 0.75rem; padding: 0.25rem 0.6rem; border-radius: 9999px; display: none; z-index: 5; }
        .image-action-btn:hover { background-color: rgba(37, 99, 235, 0.9); }
        .image-action-btn.visible { display: inline-flex; align-items: center; justify-content: center; gap: 0.25rem; }
        .image-generate-btn { background-color: rgba(16, 185, 129, 0.9); }
        .image-generate-btn:hover { background-color: rgba(5, 150, 105, 0.95); }
        .image-regen-btn { background-color: rgba(17, 24, 39, 0.85); }
        .image-upload-btn { right: 4.5rem; background-color: rgba(59, 130, 246, 0.9); }
        .image-upload-btn:hover { background-color: rgba(37, 99, 235, 0.95); }
        #notification { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #2c3e50; color: white; padding: 1rem 2rem; border-radius: 8px; z-index: 1000; transition: opacity 0.5s, transform 0.5s; opacity: 0; pointer-events: none; }
        #notification.show { opacity: 1; transform: translate(-50%, 10px); }
        .login-tab.active { border-bottom-color: #F59E0B; color: #F59E0B; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .form-input { transition: all 0.3s; }
        .form-input:focus { border-color: #F59E0B; box-shadow: 0 0 0 2px rgba(245,158,11,0.2); }
        .btn { transition: background-color 0.3s; }
        .btn-primary { background-color: #F59E0B; color: white; }
        .btn-primary:hover { background-color: #D97706; }
        .btn-secondary { background-color: #6B7280; color: white; }
        .btn-secondary:hover { background-color: #4B5563; }
        .btn-disabled { background-color: #D1D5DB; cursor: not-allowed; }
    </style>
</head>
<body class="p-2 md:p-8 bg-gray-100">

    <div id="book-login-view" class="max-w-md mx-auto mb-8 bg-white p-6 rounded-lg shadow-lg">
        <div class="border-b border-gray-200">
            <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                <button id="book-student-login-tab" class="login-tab whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">🧑‍🎓 학생</button>
                <button id="book-teacher-login-tab" class="login-tab whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">🧑‍🏫 교사</button>
            </nav>
        </div>
        <div id="book-student-login-content" class="tab-content pt-6">
            <div class="mb-4">
                <label for="book-student-code" class="block text-sm font-medium text-gray-700 mb-1">고유 숫자 코드</label>
                <input type="text" id="book-student-code" class="w-full p-2 border border-gray-300 rounded-md form-input" placeholder="발급받은 코드를 입력하세요">
            </div>
            <button id="book-student-login-btn" class="w-full py-2 rounded-md btn btn-primary">학생 로그인</button>
        </div>
        <div id="book-teacher-login-content" class="tab-content pt-6">
            <div class="mb-4">
                <label for="book-teacher-email" class="block text-sm font-medium text-gray-700 mb-1">이메일</label>
                <input type="email" id="book-teacher-email" class="w-full p-2 border border-gray-300 rounded-md form-input" placeholder="example@email.com">
            </div>
            <div class="mb-6">
                <label for="book-teacher-password" class="block text-sm font-medium text-gray-700 mb-1">비밀번호</label>
                <input type="password" id="book-teacher-password" class="w-full p-2 border border-gray-300 rounded-md form-input" placeholder="••••••••">
            </div>
            <button id="book-teacher-login-btn" class="w-full py-2 rounded-md btn btn-primary">교사 로그인</button>
            <button id="book-teacher-google-login-btn" class="w-full py-2 mt-2 rounded-md btn btn-secondary"><i class="fab fa-google mr-2"></i>Google로 로그인</button>
        </div>
        <div class="mt-6 text-center space-y-2">
            <button id="book-show-student-register-btn" class="w-full text-center text-sm text-amber-600 hover:underline">처음이신가요? 학생 등록하기</button>
            <button id="book-show-teacher-register-btn" class="w-full text-center text-sm text-amber-600 hover:underline">교사이신가요? 회원가입하기</button>
        </div>
    </div>

    <div id="book-student-register-view" class="max-w-md mx-auto mb-8 bg-white p-6 rounded-lg shadow-lg hidden">
        <h2 class="text-2xl font-bold mb-6 text-center">🧑‍🎓 학생 등록</h2>
        <div class="mb-4">
            <label for="book-student-name" class="block text-sm font-medium text-gray-700 mb-1">이름</label>
            <input type="text" id="book-student-name" class="w-full p-2 border border-gray-300 rounded-md form-input" placeholder="이름을 입력하세요">
        </div>
        <button id="book-student-register-btn" class="w-full py-2 rounded-md btn btn-primary mb-4">등록하고 코드 받기</button>
        <button id="book-back-to-login-btn" class="w-full text-center text-sm text-gray-600 hover:underline">로그인 화면으로 돌아가기</button>
    </div>

    <div id="book-teacher-register-view" class="max-w-md mx-auto mb-8 bg-white p-6 rounded-lg shadow-lg hidden">
        <h2 class="text-2xl font-bold mb-6 text-center">🧑‍🏫 교사 회원가입</h2>
        <div class="mb-4">
            <label for="book-teacher-register-name" class="block text-sm font-medium text-gray-700 mb-1">이름</label>
            <input type="text" id="book-teacher-register-name" class="w-full p-2 border border-gray-300 rounded-md form-input" placeholder="이름을 입력하세요">
        </div>
        <div class="mb-4">
            <label for="book-teacher-register-email" class="block text-sm font-medium text-gray-700 mb-1">이메일</label>
            <input type="email" id="book-teacher-register-email" class="w-full p-2 border border-gray-300 rounded-md form-input" placeholder="example@email.com">
        </div>
        <div class="mb-6">
            <label for="book-teacher-register-password" class="block text-sm font-medium text-gray-700 mb-1">비밀번호</label>
            <input type="password" id="book-teacher-register-password" class="w-full p-2 border border-gray-300 rounded-md form-input" placeholder="6자리 이상 비밀번호를 입력하세요">
        </div>
        <button id="book-teacher-register-btn" class="w-full py-2 rounded-md btn btn-primary mb-4">회원가입</button>
        <button id="book-teacher-back-to-login-btn" class="w-full text-center text-sm text-gray-600 hover:underline">로그인 화면으로 돌아가기</button>
    </div>

    <div id="book-content" class="hidden">
    <div class="max-w-7xl mx-auto mb-4 flex justify-between items-center">
        <h1 class="flex items-center gap-2 text-3xl font-extrabold text-amber-600">📚 <span>에이두 북메이커</span></h1>
        <div class="flex items-center gap-3 bg-white border rounded-full px-4 py-2">
            <span id="role-badge" class="font-bold mr-1 hidden">교사</span>
            <span id="display-user-name" class="font-bold"></span>
            <span id="display-user-code" class="text-sm text-gray-500 hidden"></span>
            <button id="token-give-btn" class="bg-purple-500 text-white px-2 py-1 rounded text-sm hidden">토큰 지급</button>
            <button id="my-class-btn" class="bg-amber-500 text-white px-2 py-1 rounded text-sm hidden">내 학급</button>
            <span class="text-sm text-gray-700">내 지갑: <span id="display-user-tokens">0</span>토큰</span>
            <button id="my-info-btn" class="text-sm text-gray-500 underline">내 정보</button>
            <button id="book-logout-btn" class="text-sm text-gray-500 underline">로그아웃</button>
        </div>
    </div>
    <div id="book-list-section" class="max-w-7xl mx-auto mb-4">
        <div class="bg-white p-4 rounded-lg shadow">
            <div class="mb-4 flex gap-4 border-b">
                <button id="my-books-tab" class="pb-2 text-sm font-medium border-b-2 border-orange-500 text-orange-500">내 책</button>
                <button id="library-tab" class="pb-2 text-sm font-medium border-b-2 border-transparent text-gray-500">에이두 도서관</button>
            </div>
            <div id="library-controls" class="hidden flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-3">
                <input type="text" id="library-search-input" class="w-full md:w-72 p-2 border border-gray-300 rounded-md form-input" placeholder="책 제목 또는 글쓴이를 검색하세요">
                <div id="library-teacher-controls" class="hidden flex items-center gap-2">
                    <button id="library-class-only-btn" class="px-3 py-1 rounded-full border border-amber-500 text-amber-600 text-sm hover:bg-amber-50">내 학급 학생들만 보기</button>
                    <button id="library-show-all-btn" class="hidden px-3 py-1 rounded-full border border-gray-400 text-gray-600 text-sm hover:bg-gray-100">전체 보기</button>
                </div>
            </div>
            <div id="my-book-list" class="flex items-stretch gap-3 overflow-x-auto pb-2"></div>
            <div id="library-book-list" class="hidden grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"></div>
        </div>
    </div>
    <div id="book-viewer-page" class="page-content max-w-7xl mx-auto hidden">
        <div class="bg-white rounded-2xl shadow-lg p-4 md:p-6">
            <header class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-4">
                <div class="flex items-end gap-2">
                    <button id="back-to-list-btn" class="bg-gray-500 text-white px-3 py-1 rounded-lg">목록으로</button>
                    <h1 class="text-2xl md:text-4xl font-bold text-emerald-800 flex items-center gap-2">📚 <span class="book-title-sync">에이두 북메이커</span></h1>
                    <span class="text-sm text-gray-600">글쓴이: <span id="author-display" class="book-author-sync"></span></span>
                </div>
                <div id="viewer-controls" class="flex flex-wrap justify-center items-center gap-2">
                    <button id="generate-images-gpt-btn" onclick="completeManualBookGPT()" class="bg-pink-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-pink-700 disabled:bg-gray-400 disabled:cursor-not-allowed hidden">GPT 사진 만들기/1토큰</button>
                    <button id="generate-images-btn" onclick="completeManualBook()" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed">한번에 그림 생성하기</button>
                    <button id="save-book-btn" onclick="saveBookDraft()" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">저장하기</button>
                    <button id="save-book-pdf-btn" onclick="downloadBookAsPDF()" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 hidden">PDF 저장</button>
                    <button id="register-library-btn" onclick="registerToLibrary()" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 disabled:bg-gray-400 disabled:cursor-not-allowed hidden">책 완성</button>
                    <button id="edit-book-btn" onclick="enableEditMode()" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 hidden">편집</button>
                </div>
            </header>

            <div id="book-viewer" class="relative bg-gray-50 rounded-lg border-2 border-dashed mb-4">
                <!-- 책 뷰어가 여기에 생성됩니다. -->
            </div>

            <div id="page-prompt-wrapper" class="mt-4"></div>
            <div id="book-like-section" class="mt-4 flex items-center gap-2 justify-end hidden">
                <button id="book-like-btn" class="px-3 py-1 bg-pink-500 text-white rounded">좋아요</button>
                <span id="book-like-count" class="text-sm text-gray-700">0</span>
            </div>
            <div id="book-comments-section" class="mt-6 hidden">
                <h3 class="font-semibold mb-2">댓글</h3>
                <div id="comments-list" class="space-y-2"></div>
                <div class="flex gap-2 mt-2">
                    <input type="text" id="new-comment-input" class="flex-1 p-2 border rounded" placeholder="댓글을 입력하세요" />
                    <button id="add-comment-btn" class="px-3 py-1 bg-blue-500 text-white rounded">등록</button>
                </div>
            </div>
        </div>
    </div>
    </div>

    <div id="notification"></div>

    <!-- 새 책 추가 팝업 -->
    <div id="add-book-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-80">
            <h2 class="text-lg font-semibold mb-4">새 책 만들기</h2>
            <input type="text" id="new-book-title" class="w-full p-2 border border-gray-300 rounded mb-4" placeholder="책 제목을 입력하세요" />
            <div class="flex justify-end gap-2">
                <button id="cancel-add-book" class="px-3 py-1 rounded bg-gray-300">취소</button>
                <button id="confirm-add-book" class="px-3 py-1 rounded bg-blue-500 text-white">확인</button>
            </div>
        </div>
    </div>

    <!-- 내 학급 팝업 -->
    <div id="my-class-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-lg">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold">내 학급</h2>
                <button id="close-my-class-modal" class="text-xl">&times;</button>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">학급 선택</label>
                <div id="my-class-list" class="flex flex-wrap gap-2"></div>
            </div>
            <ul id="my-class-student-list" class="space-y-1 max-h-60 overflow-y-auto mb-4 border rounded p-2 bg-gray-50"></ul>
            <div class="flex justify-between items-center">
                <button id="add-class-btn" class="px-3 py-1 rounded bg-green-500 text-white">학급 추가</button>
                <button id="add-my-class-student-btn" class="px-3 py-1 rounded bg-blue-500 text-white">학생 추가</button>
            </div>
        </div>
    </div>

    <!-- 학급 추가 팝업 -->
    <div id="add-class-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-80">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold">학급 추가</h2>
                <button id="close-add-class-modal" class="text-xl">&times;</button>
            </div>
            <input type="text" id="new-class-name" class="w-full p-2 border border-gray-300 rounded mb-4" placeholder="학급 이름을 입력하세요" />
            <div class="flex justify-end gap-2">
                <button id="cancel-add-class-btn" class="px-3 py-1 rounded bg-gray-300">취소</button>
                <button id="confirm-add-class-btn" class="px-3 py-1 rounded bg-green-500 text-white">완료</button>
            </div>
        </div>
    </div>

    <!-- 학급 학생 추가 팝업 -->
    <div id="class-add-students-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-96">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold flex items-center gap-2">학생 추가 <span id="class-add-students-class-name" class="text-sm text-gray-500"></span></h2>
                <button id="close-class-add-students-btn" class="text-xl">&times;</button>
            </div>
            <div class="mb-2">
                <input type="text" id="class-student-search" class="w-full p-2 border rounded" placeholder="이름 또는 코드로 검색..." />
            </div>
            <div id="class-student-list" class="space-y-2 max-h-60 overflow-y-auto border p-2 rounded mb-4"></div>
            <div class="text-right">
                <button id="class-add-students-confirm-btn" class="px-3 py-1 rounded bg-blue-500 text-white">추가</button>
            </div>
        </div>
    </div>

    <!-- 토큰 지급 팝업 -->
    <div id="token-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-96">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold">토큰 지급</h2>
                <button id="close-token-modal" class="text-xl">&times;</button>
            </div>
            <label class="flex items-center space-x-2 mb-2"><input type="checkbox" id="token-select-class" class="h-4 w-4"><span>내 학급 전체 선택</span></label>
            <input type="text" id="token-user-search" class="w-full p-2 border rounded mb-2" placeholder="이름 또는 코드로 검색..." />
            <div id="token-user-list" class="space-y-2 max-h-60 overflow-y-auto border p-2 rounded mb-4"></div>
            <input type="number" id="token-amount" class="w-full p-2 border rounded mb-4" placeholder="지급할 토큰 양" />
            <div class="text-right">
                <button id="token-distribute-confirm" class="px-3 py-1 rounded bg-purple-500 text-white">지급하기</button>
            </div>
        </div>
    </div>

    <!-- 내 정보 팝업 -->
    <div id="my-info-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-lg w-80">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold">내 정보</h2>
                <button id="close-my-info-modal" class="text-xl">&times;</button>
            </div>
            <div class="mb-4">
                <label for="my-info-name" class="block text-sm font-medium text-gray-700 mb-1">이름</label>
                <input type="text" id="my-info-name" class="w-full p-2 border rounded" />
            </div>
            <div class="text-right">
                <button id="my-info-save-btn" class="px-3 py-1 rounded bg-blue-500 text-white">변경</button>
            </div>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, GoogleAuthProvider, signInWithPopup, signOut, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, serverTimestamp, updateDoc, increment, collection, addDoc, getDocs, query, where, runTransaction, arrayUnion, deleteDoc, getCountFromServer } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref as storageRef, uploadBytes, getDownloadURL, getBlob } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        import { fetchTeacherClass, createTeacherClass, addStudentsToTeacherClass } from "./js/classManager.js";

        const urlParams = new URLSearchParams(window.location.search);
        const initialBookId = urlParams.get('bookId');
        const viewerParam = urlParams.get('viewer');
        const forceViewerMode = viewerParam === '1' || viewerParam === 'true';
        let hasAttemptedInitialBookLoad = false;

        // 전역 변수
        let bookCurrentPage = 0;
        let totalBookSpreads = 0;
        let bookCode = null;
        let bookAuthorUid = null; // 현재 로그인한 사용자 UID
        let bookOwnerUid = null;  // 책 소유자 UID
        let auth;
        let db;
        let storage;
        let userTokens = 0;
        let currentClassStudents = [];
        let teacherClasses = [];
        let selectedClassId = null;
        let isViewMode = false;
        let canEditBook = false;
        let bookIsPublic = false;
        let imagesGenerated = false;
        let imageGenerationMethod = 'stability';
        let libraryBooksCache = [];
        let libraryShowClassOnly = false;
        let imageUploadInput = null;
        let currentImageUploadTarget = null;
        // 로그인한 사용자 이름을 저장하고 책의 저자 영역을 동기화합니다.
        window.authorName = '';
        window.bookAuthorName = '';
        window.currentUserRole = 'student';
        window.syncBookAuthor = function() {
            const authorText = window.bookAuthorName || window.authorName || '';
            document.querySelectorAll('.book-author-sync').forEach(el => el.textContent = authorText);
        };

        // TTS 함수
        function speak(text) {
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'ko-KR';
                u.rate = 0.9;
                window.speechSynthesis.speak(u);
            }
        }

        // 알림 함수
        function showNotification(message, duration = 3000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }

        function normalizeImageExtension(ext) {
            if (!ext) return 'webp';
            const lowered = ext.toLowerCase();
            if (lowered === 'jpeg') return 'jpg';
            if (lowered === 'svg+xml') return 'svg';
            return lowered;
        }

        function getExtensionFromMime(mimeType) {
            const match = (mimeType || '').match(/image\/([a-zA-Z0-9+.-]+)/i);
            return normalizeImageExtension(match && match[1]);
        }

        function getExtensionFromDataUrl(dataUrl) {
            if (typeof dataUrl !== 'string') return 'webp';
            const match = dataUrl.match(/^data:image\/([^;]+)/i);
            return normalizeImageExtension(match && match[1]);
        }

        function ensureImageUploadInput() {
            if (imageUploadInput) return imageUploadInput;
            imageUploadInput = document.createElement('input');
            imageUploadInput.type = 'file';
            imageUploadInput.accept = 'image/*';
            imageUploadInput.style.display = 'none';
            imageUploadInput.addEventListener('change', handleImageUploadChange);
            document.body.appendChild(imageUploadInput);
            return imageUploadInput;
        }

        function cleanupTargetAfterUpload(target) {
            if (!target) return;
            if (target.classList.contains('character-image-box')) {
                const textNodes = Array.from(target.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                textNodes.forEach(node => target.removeChild(node));
                return;
            }
            const spread = target.closest('.book-spread');
            if (spread?.dataset.pageType === 'story') {
                target.querySelectorAll('.text-gray-400').forEach(el => el.remove());
                const textNodes = Array.from(target.childNodes).filter(node => node.nodeType === Node.TEXT_NODE && !node.textContent.trim());
                textNodes.forEach(node => target.removeChild(node));
            }
        }

        function getImageFileNameForTarget(target, extension) {
            const ext = normalizeImageExtension(extension) || 'webp';
            const spread = target.closest('.book-spread');
            if (!spread) {
                return `uploaded-${Date.now()}.${ext}`;
            }
            const type = spread.dataset.pageType;
            if (type === 'cover') {
                return `cover.${ext}`;
            }
            if (type === 'character') {
                const pages = Array.from(document.querySelectorAll('.book-spread[data-page-type="character"] .book-page'));
                const page = target.closest('.book-page');
                const index = pages.indexOf(page);
                if (index !== -1) {
                    return `character${index + 1}.${ext}`;
                }
            }
            if (type === 'story') {
                const spreads = Array.from(document.querySelectorAll('.book-spread[data-page-type="story"]'));
                const index = spreads.indexOf(spread);
                if (index !== -1) {
                    return `story${index + 1}.${ext}`;
                }
            }
            return `uploaded-${Date.now()}.${ext}`;
        }

        function applyImageUploadToTarget(target, dataUrl, file) {
            if (!target || !dataUrl) return;
            cleanupTargetAfterUpload(target);
            target.style.backgroundImage = `url('${dataUrl}')`;
            const extFromFile = getExtensionFromMime(file?.type);
            const finalExt = extFromFile || getExtensionFromDataUrl(dataUrl);
            const fileName = getImageFileNameForTarget(target, finalExt);
            target.dataset.imageName = fileName;
            const spread = target.closest('.book-spread');
            if (spread) {
                setupRegenerateButtonsForSpread(spread);
            }
            updateRegenerateButtonsVisibility();
        }

        function openImageUploadDialog(target) {
            if (!target) return;
            currentImageUploadTarget = target;
            const input = ensureImageUploadInput();
            input.value = '';
            input.click();
        }

        function handleImageUploadChange(event) {
            const file = event?.target?.files?.[0] || null;
            if (!currentImageUploadTarget || !file) {
                currentImageUploadTarget = null;
                if (event?.target) {
                    event.target.value = '';
                }
                return;
            }
            if (!file.type.startsWith('image/')) {
                showNotification('이미지 파일을 선택해주세요.');
                currentImageUploadTarget = null;
                event.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    applyImageUploadToTarget(currentImageUploadTarget, reader.result, file);
                    showNotification('이미지를 업로드했습니다.');
                } finally {
                    currentImageUploadTarget = null;
                    event.target.value = '';
                }
            };
            reader.onerror = () => {
                showNotification('이미지를 불러오지 못했습니다. 다시 시도해주세요.');
                currentImageUploadTarget = null;
                event.target.value = '';
            };
            reader.readAsDataURL(file);
        }

        function attachUploadButton(target) {
            if (!target || target.querySelector('.image-upload-btn')) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'image-action-btn image-upload-btn';
            btn.textContent = '업로드';
            btn.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                openImageUploadDialog(target);
            });
            target.appendChild(btn);
        }

        function attachGenerationButton(target, handler) {
            if (!target || target.querySelector('.image-generate-btn')) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'image-action-btn image-generate-btn';
            btn.textContent = '그림 생성';
            btn.addEventListener('click', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                await handleGenerateButtonClick(btn, handler);
            });
            target.appendChild(btn);
        }

        function attachRegenerateButton(target, handler) {
            if (!target || target.querySelector('.image-regen-btn')) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'image-action-btn image-regen-btn';
            btn.textContent = '재생성';
            btn.addEventListener('click', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                await handleRegenerateButtonClick(btn, handler);
            });
            target.appendChild(btn);
        }

        async function handleGenerateButtonClick(btn, handler) {
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = '생성중...';
            try {
                await handler();
                showNotification('그림을 생성했습니다.');
            } catch (error) {
                if (error?.message) {
                    showNotification(error.message);
                } else {
                    showNotification('그림 생성에 실패했습니다.');
                }
                console.error('Generate image failed:', error);
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
                updateRegenerateButtonsVisibility();
            }
        }

        async function consumeTokenForImageRegeneration() {
            if (!bookAuthorUid) {
                showNotification('로그인 후 이용해주세요.');
                return false;
            }

            const userRef = doc(db, 'users', bookAuthorUid);
            let tokens = Number(userTokens) || 0;

            if (tokens < 1) {
                try {
                    const snapshot = await getDoc(userRef);
                    tokens = Number(snapshot.data()?.aeduTokens) || 0;
                    userTokens = tokens;
                    const display = document.getElementById('display-user-tokens');
                    if (display) display.textContent = `${tokens}`;
                } catch (error) {
                    console.error('Failed to fetch user tokens for regeneration', error);
                    showNotification('토큰 정보를 불러오지 못했습니다. 잠시 후 다시 시도해주세요.');
                    return false;
                }
            }

            if (tokens < 1) {
                showNotification('에이두 토큰이 부족합니다.');
                return false;
            }

            try {
                await updateDoc(userRef, { aeduTokens: increment(-1) });
                tokens = Math.max(0, tokens - 1);
                userTokens = tokens;
                const display = document.getElementById('display-user-tokens');
                if (display) display.textContent = `${tokens}`;
                return true;
            } catch (error) {
                console.error('Failed to consume token for regeneration', error);
                showNotification('토큰 차감에 실패했습니다. 잠시 후 다시 시도해주세요.');
                return false;
            }
        }

        async function handleRegenerateButtonClick(btn, handler) {
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = '생성중...';
            try {
                const tokenConsumed = await consumeTokenForImageRegeneration();
                if (!tokenConsumed) return;
                await handler();
                showNotification('그림을 재생성했습니다.');
            } catch (error) {
                if (error?.message) {
                    showNotification(error.message);
                } else {
                    showNotification('그림 재생성에 실패했습니다.');
                }
                console.error('Regenerate image failed:', error);
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
                updateRegenerateButtonsVisibility();
            }
        }

        function setupRegenerateButtonsForSpread(spread) {
            if (!spread) return;
            const type = spread.dataset.pageType;
            if (type === 'cover') {
                const coverPage = spread.querySelector('.book-page:last-child');
                attachUploadButton(coverPage);
                attachGenerationButton(coverPage, () => regenerateCoverImage(spread));
                attachRegenerateButton(coverPage, () => regenerateCoverImage(spread));
            } else if (type === 'character') {
                const boxes = spread.querySelectorAll('.character-image-box');
                boxes.forEach((box) => {
                    attachUploadButton(box);
                    attachGenerationButton(box, () => regenerateCharacterImage(spread, box));
                    attachRegenerateButton(box, () => regenerateCharacterImage(spread, box));
                });
            } else if (type === 'story') {
                const imagePage = spread.querySelector('.book-page:first-child');
                attachUploadButton(imagePage);
                attachGenerationButton(imagePage, () => regenerateStoryImage(spread));
                attachRegenerateButton(imagePage, () => regenerateStoryImage(spread));
            }
            updateRegenerateButtonsVisibility();
        }

        function setupAllRegenerateButtons() {
            document.querySelectorAll('#book-viewer .book-spread').forEach(setupRegenerateButtonsForSpread);
        }

        function elementHasGeneratedImage(element) {
            if (!element) return false;
            const inlineBg = element.style?.backgroundImage;
            const computedBg = window.getComputedStyle(element).backgroundImage;
            const backgroundValue = inlineBg && inlineBg !== 'none' ? inlineBg : computedBg;
            return !!backgroundValue && backgroundValue !== 'none';
        }

        function updateRegenerateButtonsVisibility() {
            const canEdit = !isViewMode && !bookIsPublic;
            document.querySelectorAll('.image-upload-btn').forEach((btn) => {
                if (canEdit) {
                    btn.classList.add('visible');
                } else {
                    btn.classList.remove('visible');
                }
            });
            document.querySelectorAll('.image-generate-btn').forEach((btn) => {
                const parent = btn.parentElement;
                const shouldShow = canEdit && !elementHasGeneratedImage(parent);
                if (shouldShow) {
                    btn.classList.add('visible');
                } else {
                    btn.classList.remove('visible');
                }
            });
            document.querySelectorAll('.image-regen-btn').forEach((btn) => {
                const parent = btn.parentElement;
                const shouldShow = canEdit && elementHasGeneratedImage(parent);
                if (shouldShow) {
                    btn.classList.add('visible');
                } else {
                    btn.classList.remove('visible');
                }
            });
        }

        function collectCharacterPrompts() {
            const charSpreads = document.querySelectorAll('#book-viewer .book-spread[data-page-type="character"]');
            const contextParts = [];
            charSpreads.forEach((spread) => {
                const prompts = [spread.dataset.promptLeft, spread.dataset.promptRight];
                const descriptions = spread.querySelectorAll('textarea');
                const names = spread.querySelectorAll('.editable-text');
                prompts.forEach((prompt, index) => {
                    if (!prompt) {
                        const desc = descriptions[index]?.value?.trim() || '';
                        const name = names[index]?.textContent?.trim() || '';
                        const combined = [name, desc].filter(Boolean).join(', ');
                        if (combined) {
                            prompt = combined;
                        }
                    }
                    if (prompt) {
                        contextParts.push(prompt);
                    }
                });
            });
            return contextParts.join('\n');
        }

        function buildStoryContextForSpread(targetSpread) {
            const parts = [];
            const characterContext = collectCharacterPrompts();
            if (characterContext) {
                parts.push(`등장인물 정보: ${characterContext}`);
            }
            const storySpreads = Array.from(document.querySelectorAll('#book-viewer .book-spread[data-page-type="story"]'));
            for (const spread of storySpreads) {
                if (spread === targetSpread) break;
                const text = spread.querySelector('textarea')?.value?.trim() || '';
                const extra = spread.dataset.prompt || '';
                if (text) parts.push(`이전 줄거리: ${text}`);
                if (extra) parts.push(`이전 추가 설명: ${extra}`);
            }
            return parts.join('\n');
        }

        async function generateImageUsingCurrentMethod(prompt, context = '') {
            const trimmedPrompt = (prompt || '').trim();
            if (!trimmedPrompt) {
                throw new Error('이미지를 재생성할 내용을 입력해주세요.');
            }
            if (imageGenerationMethod === 'gpt') {
                return await generateImageForParagraphGPT(trimmedPrompt, context);
            }
            return await generateImageForParagraph(trimmedPrompt, context);
        }

        async function regenerateCoverImage(spread) {
            const coverPage = spread.querySelector('.book-page:last-child');
            if (!coverPage) return;
            const promptSource = spread.dataset.prompt || document.querySelector('#spread-0 .book-title-sync')?.textContent || '';
            const characterContext = collectCharacterPrompts();
            const imageUrl = await generateImageUsingCurrentMethod(promptSource, characterContext);
            coverPage.style.backgroundImage = `url('${imageUrl}')`;
        }

        async function regenerateCharacterImage(spread, box) {
            const boxes = Array.from(spread.querySelectorAll('.character-image-box'));
            const index = boxes.indexOf(box);
            if (index === -1) return;
            const prompts = [spread.dataset.promptLeft, spread.dataset.promptRight];
            let prompt = prompts[index] || '';
            if (!prompt) {
                const descriptions = spread.querySelectorAll('textarea');
                const names = spread.querySelectorAll('.editable-text');
                const desc = descriptions[index]?.value?.trim() || '';
                const name = names[index]?.textContent?.trim() || '';
                prompt = [name, desc].filter(Boolean).join(', ');
            }
            const basePrompt = prompt.trim();
            if (!basePrompt) {
                throw new Error('등장인물 정보를 입력해주세요.');
            }
            const finalPrompt = `${basePrompt}, 동일한 파스텔 색감과 몽환적인 분위기를 지닌 단일 캐릭터 장면`;
            const imageUrl = await generateImageUsingCurrentMethod(finalPrompt, '');
            box.style.backgroundImage = `url('${imageUrl}')`;
            box.textContent = '';
            delete box.dataset.imageName;
            setupRegenerateButtonsForSpread(spread);
        }

        async function regenerateStoryImage(spread) {
            const textArea = spread.querySelector('.book-page:last-child textarea');
            const storyText = textArea?.value?.trim() || '';
            const extra = spread.dataset.prompt || '';
            const prompt = [storyText, extra].filter(Boolean).join('\n').trim();
            if (!prompt) {
                throw new Error('이 페이지에 대한 이야기를 입력해주세요.');
            }
            const context = buildStoryContextForSpread(spread);
            const imageUrl = await generateImageUsingCurrentMethod(prompt, context);
            const imagePage = spread.querySelector('.book-page:first-child');
            if (!imagePage) return;
            const pageNumber = imagePage.querySelector('.page-number');
            const pageNumberHTML = pageNumber ? pageNumber.outerHTML : '';
            imagePage.style.backgroundImage = `url('${imageUrl}')`;
            imagePage.innerHTML = pageNumberHTML;
            delete imagePage.dataset.imageName;
            setupRegenerateButtonsForSpread(spread);
        }

        async function ensureBookUserDocument(user) {
            if (!user) return null;
            const userRef = doc(db, 'users', user.uid);
            const existingDoc = await getDoc(userRef);

            const providerData = Array.isArray(user.providerData) && user.providerData.length > 0 ? user.providerData[0] : null;
            const displayName = (user.displayName || '').trim();
            const inferredName = providerData && providerData.displayName ? providerData.displayName.trim() : '';
            const fallbackName = user.email ? user.email.split('@')[0] : '';
            const finalName = displayName || inferredName || fallbackName || '새 사용자';

            if (existingDoc.exists()) {
                const data = existingDoc.data() || {};
                const updates = {};
                if (!data.uid) updates.uid = user.uid;
                if (!data.name) updates.name = finalName;
                const providerEmail = providerData && providerData.email ? providerData.email : '';
                if (!data.email && (user.email || providerEmail)) {
                    updates.email = user.email || providerEmail;
                }
                const normalizedRole = typeof data.role === 'string' ? data.role.toLowerCase() : '';
                if (normalizedRole === 'teacher' && data.role !== 'teacher') {
                    updates.role = 'teacher';
                } else if (normalizedRole === 'student' && data.role !== 'student') {
                    updates.role = 'student';
                } else if (!['teacher', 'student'].includes(normalizedRole)) {
                    updates.role = 'student';
                }
                if (data.aeduTokens === undefined) updates.aeduTokens = 0;
                if (data.aeduExperience === undefined) updates.aeduExperience = 0;
                if (data.aeduLevel === undefined) updates.aeduLevel = 1;
                if (data.warningTokens === undefined) updates.warningTokens = 0;
                if (Object.keys(updates).length > 0) {
                    await setDoc(userRef, updates, { merge: true });
                    return await getDoc(userRef);
                }
                return existingDoc;
            }

            const providerEmail = providerData && providerData.email ? providerData.email : '';
            const newUserData = {
                uid: user.uid,
                name: finalName,
                email: user.email || providerEmail || '',
                role: 'student',
                userCode: null,
                coins: 0,
                balance: 0,
                portfolio: {},
                aeduTokens: 0,
                aeduExperience: 0,
                aeduLevel: 1,
                warningTokens: 0,
                createdAt: serverTimestamp()
            };

            await setDoc(userRef, newUserData, { merge: true });
            return await getDoc(userRef);
        }

        // 간단한 HTML 이스케이프
        function escapeHTML(str) {
            return str.replace(/[&<>"']/g, m => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[m]));
        }

        async function loadUserBooks() {
            if (!bookAuthorUid) return;
            const listEl = document.getElementById('my-book-list');
            listEl.innerHTML = '';
            try {
                const snap = await getDocs(collection(db, `users/${bookAuthorUid}/myBooks`));
                if (snap.empty) {
                    const emptyEl = document.createElement('div');
                    emptyEl.className = 'min-w-[200px] max-w-[220px] flex-shrink-0 border border-dashed border-gray-300 rounded-lg p-3 text-sm text-gray-500 flex items-center justify-center text-center';
                    emptyEl.textContent = '아직 만든 책이 없습니다.';
                    listEl.appendChild(emptyEl);
                }
                snap.forEach(docSnap => {
                    const data = docSnap.data();
                    const item = document.createElement('div');
                    item.className = 'relative min-w-[200px] max-w-[220px] flex-shrink-0 bg-white border border-gray-200 rounded-lg p-3 shadow-sm cursor-pointer hover:shadow-md transition';
                    item.addEventListener('click', () => loadBook(data.bookId));

                    const titleEl = document.createElement('div');
                    titleEl.className = 'font-semibold text-base truncate';
                    titleEl.textContent = data.title || '제목없음';
                    item.appendChild(titleEl);

                    const created = data.createdAt?.toDate ? data.createdAt.toDate().toLocaleDateString('ko-KR') : '';
                    if (created) {
                        const createdEl = document.createElement('div');
                        createdEl.className = 'text-xs text-gray-500 mt-1';
                        createdEl.textContent = `생성일: ${created}`;
                        item.appendChild(createdEl);
                    }

                    const codeEl = document.createElement('div');
                    codeEl.className = 'text-xs text-gray-500';
                    codeEl.textContent = `코드: ${data.bookId}`;
                    item.appendChild(codeEl);

                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.className = 'absolute top-2 right-2 text-red-500 hover:text-red-600';
                    deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                    deleteBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        deleteMyBook(docSnap.id, data.bookId);
                    });
                    item.appendChild(deleteBtn);

                    listEl.appendChild(item);
                });
            } catch (error) {
                console.error('Failed to load user books:', error);
                const errorEl = document.createElement('div');
                errorEl.className = 'min-w-[200px] max-w-[220px] flex-shrink-0 border border-red-200 bg-red-50 text-red-600 rounded-lg p-3 text-sm';
                errorEl.textContent = '내 책을 불러오지 못했습니다.';
                listEl.appendChild(errorEl);
            }

            const addBtn = document.createElement('button');
            addBtn.id = 'add-book-btn';
            addBtn.className = 'min-w-[200px] max-w-[220px] flex-shrink-0 border-2 border-dashed border-amber-400 text-amber-600 rounded-lg p-3 text-sm font-semibold hover:bg-amber-50 transition';
            addBtn.textContent = '+ 책 추가/1토큰';
            addBtn.addEventListener('click', () => {
                if (!bookAuthorUid) return;
                newBookTitleInput.value = '';
                addBookModal.classList.remove('hidden');
                newBookTitleInput.focus();
            });
            listEl.appendChild(addBtn);
        }

        async function deleteMyBook(myBookDocId, bookId) {
            if (!bookAuthorUid) return;
            if (!confirm('정말 삭제하시겠습니까?')) return;
            try {
                await deleteDoc(doc(db, `users/${bookAuthorUid}/myBooks`, myBookDocId));
            } catch (error) {
                console.error('Failed to remove book from my list:', error);
                showNotification(`내 책 삭제 실패: ${error.message}`);
                return;
            }
            try {
                await deleteDoc(doc(db, 'Book', bookId));
            } catch (error) {
                console.warn('Failed to delete book document:', error);
            }
            showNotification('책이 삭제되었습니다.');
            await loadUserBooks();
            await loadLibraryBooks();
        }

        async function loadLibraryBooks() {
            const listEl = document.getElementById('library-book-list');
            if (!listEl) return;
            listEl.innerHTML = '<div class="col-span-full text-sm text-gray-500">도서관을 불러오는 중...</div>';
            libraryBooksCache = [];
            try {
                const q = query(collection(db, 'Book'), where('isPublic', '==', true));
                const snap = await getDocs(q);
                const books = [];
                for (const docSnap of snap.docs) {
                    const data = docSnap.data();
                    let coverUrl = '';
                    if (data.coverImage) {
                        try {
                            coverUrl = await getDownloadURL(storageRef(storage, `Book/${docSnap.id}/${data.coverImage}`));
                        } catch (e) {
                            console.error('Failed to load cover image:', e);
                        }
                    }
                    const storedLikes = typeof data.likesCount === 'number' ? data.likesCount : Number(data.likesCount) || 0;
                    const storedComments = typeof data.commentsCount === 'number' ? data.commentsCount : Number(data.commentsCount) || 0;
                    books.push({
                        id: docSnap.id,
                        data: { ...data, likesCount: storedLikes, commentsCount: storedComments },
                        coverUrl,
                        storedCounts: { likesCount: storedLikes, commentsCount: storedComments }
                    });
                }

                await Promise.all(books.map(async (book) => {
                    try {
                        const [likesSnap, commentsSnap] = await Promise.all([
                            getCountFromServer(collection(db, 'Book', book.id, 'likes')),
                            getCountFromServer(collection(db, 'Book', book.id, 'comments'))
                        ]);
                        const likesCount = likesSnap.data().count || 0;
                        const commentsCount = commentsSnap.data().count || 0;
                        book.data.likesCount = likesCount;
                        book.data.commentsCount = commentsCount;
                        if (book.storedCounts.likesCount !== likesCount || book.storedCounts.commentsCount !== commentsCount) {
                            await updateDoc(doc(db, 'Book', book.id), {
                                likesCount,
                                commentsCount
                            });
                        }
                    } catch (countsError) {
                        console.error('Failed to sync book counts:', countsError);
                    }
                }));

                libraryBooksCache = books.map(({ storedCounts, ...rest }) => rest);
                renderLibraryBooks();
                updateLibraryTeacherControls();
            } catch (error) {
                console.error('Failed to load library books:', error);
                listEl.innerHTML = `<div class="col-span-full text-sm text-red-500">도서관을 불러오지 못했습니다: ${error.message}</div>`;
            }
        }

        function renderLibraryBooks() {
            const listEl = document.getElementById('library-book-list');
            if (!listEl) return;
            const searchTerm = (librarySearchInput?.value || '').trim().toLowerCase();
            const classOnly = libraryShowClassOnly && window.currentUserRole === 'teacher';
            const classStudentSet = new Set(currentClassStudents || []);

            const filtered = libraryBooksCache.filter(({ data }) => {
                const title = (data.title || '').toLowerCase();
                const author = (data.author || '').toLowerCase();
                const matchesSearch = !searchTerm || title.includes(searchTerm) || author.includes(searchTerm);
                if (!matchesSearch) return false;
                if (!classOnly) return true;
                const ownerId = data.authorId || data.owner || '';
                return ownerId && classStudentSet.has(ownerId);
            });

            listEl.innerHTML = '';

            if (filtered.length === 0) {
                const emptyEl = document.createElement('div');
                emptyEl.className = 'col-span-full text-sm text-gray-500 bg-gray-50 border border-dashed border-gray-300 rounded-lg p-4 text-center';
                emptyEl.textContent = '조건에 맞는 책이 없습니다.';
                listEl.appendChild(emptyEl);
                return;
            }

            filtered.forEach((book) => {
                const { id, data, coverUrl } = book;
                const card = document.createElement('div');
                card.className = 'relative bg-white border border-gray-200 rounded-xl p-4 shadow-sm hover:shadow-md transition cursor-pointer flex flex-col gap-2';
                card.addEventListener('click', () => loadBook(id));

                const coverEl = document.createElement('div');
                coverEl.className = 'w-full h-40 bg-gray-200 rounded-lg bg-cover bg-center';
                if (coverUrl) {
                    coverEl.style.backgroundImage = `url('${coverUrl}')`;
                }
                card.appendChild(coverEl);

                const titleEl = document.createElement('div');
                titleEl.className = 'font-semibold text-lg truncate';
                titleEl.textContent = data.title || '제목없음';
                card.appendChild(titleEl);

                const authorEl = document.createElement('div');
                authorEl.className = 'text-sm text-gray-600 truncate';
                authorEl.textContent = `글쓴이: ${data.author || '알 수 없음'}`;
                card.appendChild(authorEl);

                const metaEl = document.createElement('div');
                metaEl.className = 'text-xs text-gray-500';
                const likesDisplay = typeof data.likesCount === 'number' ? data.likesCount : Number(data.likesCount) || 0;
                const commentsDisplay = typeof data.commentsCount === 'number' ? data.commentsCount : Number(data.commentsCount) || 0;
                metaEl.textContent = `좋아요 ${likesDisplay} · 댓글 ${commentsDisplay}`;
                card.appendChild(metaEl);

                const codeEl = document.createElement('div');
                codeEl.className = 'text-xs text-gray-400';
                codeEl.textContent = `코드: ${id}`;
                card.appendChild(codeEl);

                if (window.currentUserRole === 'teacher') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.className = 'absolute top-2 right-2 text-xs px-2 py-1 rounded-full bg-white/90 border border-red-200 text-red-500 hover:bg-red-50';
                    deleteBtn.textContent = '삭제';
                    deleteBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        removeLibraryBook(id);
                    });
                    card.appendChild(deleteBtn);
                }

                listEl.appendChild(card);
            });
        }

        function updateLibraryCacheCounts(bookId, counts = {}) {
            if (!bookId) return;
            let didChange = false;
            libraryBooksCache = libraryBooksCache.map((book) => {
                if (book.id !== bookId) return book;
                const updatedData = { ...book.data };
                let bookChanged = false;
                if (counts.likesCount !== undefined) {
                    const normalizedLikes = Number(counts.likesCount);
                    const likesValue = Number.isFinite(normalizedLikes) ? normalizedLikes : 0;
                    if (updatedData.likesCount !== likesValue) {
                        updatedData.likesCount = likesValue;
                        bookChanged = true;
                    }
                }
                if (counts.commentsCount !== undefined) {
                    const normalizedComments = Number(counts.commentsCount);
                    const commentsValue = Number.isFinite(normalizedComments) ? normalizedComments : 0;
                    if (updatedData.commentsCount !== commentsValue) {
                        updatedData.commentsCount = commentsValue;
                        bookChanged = true;
                    }
                }
                if (bookChanged) {
                    didChange = true;
                    return { ...book, data: updatedData };
                }
                return book;
            });
            if (didChange) {
                renderLibraryBooks();
            }
        }

        async function removeLibraryBook(bookId) {
            if (window.currentUserRole !== 'teacher') return;
            if (!confirm('정말 삭제하시겠습니까?')) return;
            try {
                await updateDoc(doc(db, 'Book', bookId), {
                    isPublic: false,
                    publishedAt: null
                });
                showNotification('도서관에서 책을 삭제했습니다.');
                await loadLibraryBooks();
            } catch (error) {
                console.error('Failed to remove book from library:', error);
                showNotification(`도서관 삭제 실패: ${error.message}`);
            }
        }

        async function loadBookLikes() {
            const countEl = document.getElementById('book-like-count');
            const likeBtn = document.getElementById('book-like-btn');
            if (!countEl || !likeBtn || !bookCode) return;
            countEl.textContent = '0';
            likeBtn.disabled = false;
            try {
                const bookRef = doc(db, 'Book', bookCode);
                const bookSnap = await getDoc(bookRef);
                const storedLikes = Number(bookSnap.data()?.likesCount) || 0;
                let likesCount = storedLikes;
                try {
                    const likesSnap = await getCountFromServer(collection(db, 'Book', bookCode, 'likes'));
                    likesCount = likesSnap.data().count || 0;
                    if (likesCount !== storedLikes) {
                        await updateDoc(bookRef, { likesCount });
                    }
                } catch (countErr) {
                    console.error('Failed to refresh like count:', countErr);
                }
                countEl.textContent = likesCount.toString();
                updateLibraryCacheCounts(bookCode, { likesCount });
                const user = auth.currentUser;
                if (user) {
                    const likeDoc = await getDoc(doc(db, `Book/${bookCode}/likes`, user.uid));
                    if (likeDoc.exists()) likeBtn.disabled = true;
                }
            } catch (err) {
                console.error(err);
            }
        }

        async function likeBook() {
            if (!auth?.currentUser || !bookCode) return;
            const user = auth.currentUser;
            const likeRef = doc(db, `Book/${bookCode}/likes`, user.uid);
            const countEl = document.getElementById('book-like-count');
            try {
                await runTransaction(db, async (tx) => {
                    const likeDoc = await tx.get(likeRef);
                    if (likeDoc.exists()) throw new Error('already');
                    tx.set(likeRef, { createdAt: serverTimestamp() });
                    tx.update(doc(db, 'Book', bookCode), { likesCount: increment(1) });
                });
                countEl.textContent = (Number(countEl.textContent) + 1).toString();
            } catch (e) {
                console.error(e);
            }
            await loadBookLikes();
        }

        async function loadComments() {
            const listEl = document.getElementById('comments-list');
            listEl.innerHTML = '';
            if (!bookCode) return;
            try {
                const currentUser = auth?.currentUser || null;
                const snap = await getDocs(collection(db, `Book/${bookCode}/comments`));
                const comments = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                const commentsCount = comments.length;
                updateLibraryCacheCounts(bookCode, { commentsCount });
                try {
                    await updateDoc(doc(db, 'Book', bookCode), { commentsCount });
                } catch (syncErr) {
                    console.error('Failed to refresh comment count:', syncErr);
                }
                comments.sort((a, b) => {
                    const likeA = a.likesCount || 0;
                    const likeB = b.likesCount || 0;
                    if (likeA !== likeB) return likeB - likeA;
                    const timeA = a.createdAt?.toMillis ? a.createdAt.toMillis() : 0;
                    const timeB = b.createdAt?.toMillis ? b.createdAt.toMillis() : 0;
                    return timeA - timeB;
                });
                let html = '';
                for (const c of comments) {
                    let liked = false;
                    if (auth.currentUser) {
                        try {
                            const likeDoc = await getDoc(doc(db, `Book/${bookCode}/comments/${c.id}/likes`, auth.currentUser.uid));
                            liked = likeDoc.exists();
                        } catch (_) {}
                    }
                    const dateStr = c.createdAt?.toDate ? c.createdAt.toDate().toLocaleDateString('ko-KR') : '';
                    const canDeleteComment = currentUser && (currentUser.uid === bookOwnerUid || window.currentUserRole === 'teacher');
                    const deleteBtnHtml = canDeleteComment ? `<button class="text-xs text-red-500 hover:underline comment-delete-btn" data-id="${c.id}">삭제</button>` : '';
                    html += `<div class="border p-2 rounded" data-id="${c.id}">` +
                            `<div class="flex items-start justify-between text-sm mb-1"><div><span class="font-semibold">${escapeHTML(c.authorName || '')}</span> <span class="text-xs text-gray-500">${dateStr}</span></div>${deleteBtnHtml}</div>` +
                            `<div class="mb-1">${escapeHTML(c.text || '')}</div>` +
                            `<button class="text-xs text-blue-500 comment-like-btn" data-id="${c.id}" ${liked ? 'disabled' : ''}>추천 ${c.likesCount || 0}</button>` +
                            `</div>`;
                }
                listEl.innerHTML = html;
                document.querySelectorAll('.comment-like-btn').forEach(btn => {
                    btn.addEventListener('click', () => likeComment(btn.dataset.id));
                });
                document.querySelectorAll('.comment-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        deleteComment(btn.dataset.id);
                    });
                });
            } catch (err) {
                console.error(err);
            }
        }

        async function addComment() {
            const input = document.getElementById('new-comment-input');
            const text = input.value.trim();
            if (!text || !auth?.currentUser || !bookCode) return;
            input.value = '';
            try {
                await addDoc(collection(db, `Book/${bookCode}/comments`), {
                    text,
                    authorName: window.authorName || '',
                    authorUid: auth.currentUser.uid,
                    createdAt: serverTimestamp(),
                    likesCount: 0
                });
                await updateDoc(doc(db, 'Book', bookCode), { commentsCount: increment(1) });
            } catch (err) {
                console.error(err);
            }
            await loadComments();
        }

        async function deleteComment(id) {
            if (!auth?.currentUser || !bookCode) return;
            const isAuthor = auth.currentUser.uid === bookOwnerUid;
            const isTeacher = window.currentUserRole === 'teacher';
            if (!isAuthor && !isTeacher) {
                showNotification('댓글을 삭제할 권한이 없습니다.');
                return;
            }
            if (!confirm('이 댓글을 삭제하시겠어요?')) {
                return;
            }
            try {
                await deleteDoc(doc(db, `Book/${bookCode}/comments`, id));
                await updateDoc(doc(db, 'Book', bookCode), { commentsCount: increment(-1) });
            } catch (err) {
                console.error(err);
                showNotification('댓글 삭제에 실패했습니다.');
            }
            await loadComments();
        }

        async function likeComment(id) {
            if (!auth?.currentUser || !bookCode) return;
            const likeRef = doc(db, `Book/${bookCode}/comments/${id}/likes`, auth.currentUser.uid);
            const commentRef = doc(db, `Book/${bookCode}/comments`, id);
            try {
                await runTransaction(db, async (tx) => {
                    const likeDoc = await tx.get(likeRef);
                    if (likeDoc.exists()) throw new Error('already');
                    tx.set(likeRef, { createdAt: serverTimestamp() });
                    tx.update(commentRef, { likesCount: increment(1) });
                });
            } catch (err) {
                console.error(err);
            }
            await loadComments();
        }

        async function loadBook(id) {
            const bookRef = doc(db, 'Book', id);
            const bookDoc = await getDoc(bookRef);
            if (!bookDoc.exists()) {
                alert('책을 불러올 수 없습니다.');
                return;
            }
            bookCode = id;
            const data = bookDoc.data();
            bookOwnerUid = data.owner || data.authorId || auth.currentUser.uid;
            bookIsPublic = !!data.isPublic;
            imagesGenerated = !!data.coverImage;
            canEditBook = auth.currentUser && (auth.currentUser.uid === bookOwnerUid || window.currentUserRole === 'teacher');
            buildBookViewer();

            for (let i = 1; i < (data.characterSpreadCount || 1); i++) {
                addCharacterPage();
            }
            for (let i = 1; i < (data.storySpreadCount || 1); i++) {
                addManualPage();
            }

            const coverSpread = document.querySelector('#spread-0');
            if (coverSpread && data.coverPrompt !== undefined) {
                coverSpread.dataset.prompt = data.coverPrompt || '';
            }

            document.querySelectorAll('.book-title-sync').forEach(el => {
                el.textContent = data.title || '';
            });
            window.bookAuthorName = data.author || window.bookAuthorName || window.authorName || '';
            window.syncBookAuthor();

            if (data.coverImage) {
                try {
                    const url = await getDownloadURL(storageRef(storage, `Book/${bookCode}/${data.coverImage}`));
                    const coverPage = document.querySelector('#spread-0 .book-page:nth-child(2)');
                    coverPage.style.backgroundImage = `url('${url}')`;
                    coverPage.dataset.imageName = data.coverImage;
                } catch (e) {
                    console.error(e);
                }
            }

            const charPages = document.querySelectorAll('.book-spread[data-page-type="character"] .book-page');
            for (let i = 0; i < charPages.length; i++) {
                const idx = i + 1;
                const page = charPages[i];
                const imgName = data[`character${idx}Image`];
                if (imgName) {
                    try {
                        const url = await getDownloadURL(storageRef(storage, `Book/${bookCode}/${imgName}`));
                        const box = page.querySelector('.character-image-box');
                        box.style.backgroundImage = `url('${url}')`;
                        box.dataset.imageName = imgName;
                        box.textContent = '';
                    } catch (e) {
                        console.error(e);
                    }
                }
                const nameVal = data[`character${idx}Name`];
                if (nameVal) page.querySelector('.editable-text').textContent = nameVal;
                const descVal = data[`character${idx}Desc`];
                if (descVal) page.querySelector('textarea.manual-text-area').value = descVal;
            }

            const charSpreads = document.querySelectorAll('.book-spread[data-page-type="character"]');
            charSpreads.forEach((spread, idx) => {
                const base = idx * 2 + 1;
                const leftPrompt = data[`character${base}Prompt`];
                const rightPrompt = data[`character${base + 1}Prompt`];
                if (leftPrompt !== undefined) spread.dataset.promptLeft = leftPrompt;
                if (rightPrompt !== undefined) spread.dataset.promptRight = rightPrompt;
            });

            const storySpreads = document.querySelectorAll('.book-spread[data-page-type="story"]');
            for (let i = 0; i < storySpreads.length; i++) {
                const idx = i + 1;
                const spread = storySpreads[i];
                const imgName = data[`story${idx}Image`];
                if (imgName) {
                    try {
                        const url = await getDownloadURL(storageRef(storage, `Book/${bookCode}/${imgName}`));
                        const imagePage = spread.querySelector('.book-page:first-child');
                        const pageNumHTML = imagePage.querySelector('.page-number')?.outerHTML || '';
                        imagePage.style.backgroundImage = `url('${url}')`;
                        imagePage.innerHTML = pageNumHTML;
                        imagePage.dataset.imageName = imgName;
                    } catch (e) {
                        console.error(e);
                    }
                }
                const textVal = data[`story${idx}Text`];
                if (textVal) spread.querySelector('.book-page:last-child textarea.manual-text-area').value = textVal;
                const promptVal = data[`story${idx}Prompt`];
                if (promptVal !== undefined) spread.dataset.prompt = promptVal;
            }

            setupAllRegenerateButtons();

            document.getElementById('book-viewer-page').classList.remove('hidden');
            document.getElementById('book-list-section').classList.add('hidden');
            bookCurrentPage = 0;
            setViewMode(bookIsPublic);
            await loadBookLikes();
            await loadComments();
        }

        async function updateUserInfo(prefetchedData = null) {
            if (!bookAuthorUid) return;
            let data = prefetchedData || null;
            if (!data) {
                const userRef = doc(db, 'users', bookAuthorUid);
                const userDoc = await getDoc(userRef);
                data = userDoc.data() || {};
            }
            window.authorName = data.name || '';
            if (!window.bookAuthorName) {
                window.bookAuthorName = window.authorName;
            }
            userTokens = Number(data.aeduTokens) || 0;
            window.currentUserRole = data.role || 'student';
            document.getElementById('display-user-name').textContent = window.authorName;
            const displayUserCodeEl = document.getElementById('display-user-code');
            const userCode = data.userCode ? String(data.userCode) : '';
            if (displayUserCodeEl) {
                if (userCode) {
                    displayUserCodeEl.textContent = `코드: ${userCode}`;
                    displayUserCodeEl.classList.remove('hidden');
                } else {
                    displayUserCodeEl.textContent = '';
                    displayUserCodeEl.classList.add('hidden');
                }
            }
            document.getElementById('display-user-tokens').textContent = `${userTokens}`;
            const roleBadgeEl = document.getElementById('role-badge');
            const myClassBtn = document.getElementById('my-class-btn');
            const tokenGiveBtn = document.getElementById('token-give-btn');
            if (data.role === 'teacher') {
                roleBadgeEl.classList.remove('hidden');
                roleBadgeEl.textContent = '교사';
                myClassBtn.classList.remove('hidden');
                tokenGiveBtn.classList.remove('hidden');
                await loadTeacherClassStudents();
            } else {
                roleBadgeEl.classList.add('hidden');
                myClassBtn.classList.add('hidden');
                tokenGiveBtn.classList.add('hidden');
                currentClassStudents = [];
            }
            window.syncBookAuthor();
            updateLibraryTeacherControls();
            return data;
        }

        async function loadTeacherClassStudents({ keepSelection = false, skipLibraryRender = false } = {}) {
            if (!bookAuthorUid) {
                teacherClasses = [];
                currentClassStudents = [];
                selectedClassId = null;
                if (!skipLibraryRender) renderLibraryBooks();
                return;
            }
            try {
                const classData = await fetchTeacherClass(db, bookAuthorUid);
                if (classData) {
                    teacherClasses = [{
                        id: classData.id,
                        name: classData.name || '이름 없는 학급',
                        students: Array.isArray(classData.students) ? classData.students : []
                    }];
                    if (!keepSelection || !selectedClassId) {
                        selectedClassId = classData.id;
                    }
                    currentClassStudents = Array.isArray(classData.students) ? classData.students : [];
                } else {
                    teacherClasses = [];
                    currentClassStudents = [];
                    if (!keepSelection) {
                        selectedClassId = null;
                    }
                }

                if (!skipLibraryRender) {
                    renderLibraryBooks();
                    updateLibraryTeacherControls();
                }
                updateAddClassButtonState();
            } catch (error) {
                console.error('Failed to load class students:', error);
                teacherClasses = [];
                currentClassStudents = [];
                if (!keepSelection) {
                    selectedClassId = null;
                }
                if (!skipLibraryRender) renderLibraryBooks();
                updateAddClassButtonState();
            }
        }

        function updateLibraryTeacherControls() {
            const libraryTeacherControls = document.getElementById('library-teacher-controls');
            const classOnlyBtn = document.getElementById('library-class-only-btn');
            const showAllBtn = document.getElementById('library-show-all-btn');
            if (!libraryTeacherControls || !classOnlyBtn || !showAllBtn) return;
            if (window.currentUserRole === 'teacher') {
                libraryTeacherControls.classList.remove('hidden');
                if (libraryShowClassOnly) {
                    classOnlyBtn.classList.add('hidden');
                    showAllBtn.classList.remove('hidden');
                } else {
                    classOnlyBtn.classList.remove('hidden');
                    showAllBtn.classList.add('hidden');
                }
            } else {
                libraryTeacherControls.classList.add('hidden');
                libraryShowClassOnly = false;
                classOnlyBtn.classList.remove('hidden');
                showAllBtn.classList.add('hidden');
            }
        }

        /**
         * 이미지 생성 API를 모방하는 함수입니다.
         * 실제로는 서버에 요청을 보내야 하지만, 여기서는 플레이스홀더 이미지 URL을 반환합니다.
         */
        const IMAGE_STYLE_INSTRUCTION = "모든 장면은 부드럽고 몽환적인 파스텔톤의 아기자기한 그림체로 통일하고, 표지와 등장인물, 줄거리 장면이 동일한 색감과 분위기로 이어지도록 해주세요.";
        const PROMPT_STYLE_SUFFIX = ", soft dreamy pastel colors, cohesive whimsical storybook illustration, consistent color palette";
        const MAX_IMAGE_PROMPT_LENGTH = 2000;
        const MAX_PROMPT_CORE_LENGTH = Math.max(1, MAX_IMAGE_PROMPT_LENGTH - PROMPT_STYLE_SUFFIX.length);
        const DEFAULT_PROMPT_FALLBACK = "Storybook illustration";

        function normalizePromptText(text = "") {
            return text.toString().replace(/\s+/g, ' ').trim();
        }

        function truncatePrompt(text = "", maxLength = MAX_PROMPT_CORE_LENGTH) {
            if (!text) return "";
            if (text.length <= maxLength) return text;
            return text.slice(0, maxLength).trim();
        }

        function buildFinalImagePrompt(baseText, translatedText) {
            const cleanedTranslated = normalizePromptText(translatedText);
            const cleanedBase = normalizePromptText(baseText);
            let promptCore = cleanedTranslated || cleanedBase || DEFAULT_PROMPT_FALLBACK;
            promptCore = truncatePrompt(promptCore, MAX_PROMPT_CORE_LENGTH);
            if (!promptCore) {
                promptCore = DEFAULT_PROMPT_FALLBACK;
            }
            return `${promptCore}${PROMPT_STYLE_SUFFIX}`;
        }

        async function translateToEnglish(text) {
            try {
                const payload = {
                    contents: [{ role: 'user', parts: [{ text: `Translate the following text to English:\n${text}` }] }]
                };
                const res = await fetch('/.netlify/functions/gemini-handler', {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error?.message || 'Gemini API Error');
                return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || text;
            } catch (error) {
                console.error('Translation failed:', error);
                return text;
            }
        }

        async function generateImageForParagraph(text, context = "") {
            const promptParts = [text];
            if (context) promptParts.push(context);
            promptParts.push(IMAGE_STYLE_INSTRUCTION);
            const basePrompt = promptParts.filter(Boolean).map(part => part.toString().trim()).filter(Boolean).join('\n');
            const limitedBasePrompt = truncatePrompt(basePrompt);
            const englishPrompt = await translateToEnglish(limitedBasePrompt || basePrompt);
            const finalPrompt = buildFinalImagePrompt(limitedBasePrompt, englishPrompt);
            const res = await fetch('/.netlify/functions/stability-handler', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    type: 'stability',
                    payload: {
                        text_prompts: [{ text: finalPrompt }],
                        cfg_scale: 7,
                        height: 1024,
                        width: 1024,
                        samples: 1,
                        steps: 30,
                        output_format: 'webp'
                    }
                })
            });

            let data;
            try {
                data = await res.json();
            } catch (_) {
                throw new Error('서버 응답을 파싱하지 못했습니다.');
            }

            if (!res.ok) {
                const message = data.error?.message || data.error || 'Stability API Error';
                throw new Error(message);
            }

            const base64 = data.image || data.artifacts?.[0]?.base64;
            if (!base64) {
                throw new Error('이미지 데이터가 없습니다.');
            }

            return `data:image/webp;base64,${base64}`;
        }

        async function generateImageForParagraphGPT(text, context = "") {
            const promptParts = [text];
            if (context) promptParts.push(context);
            promptParts.push(IMAGE_STYLE_INSTRUCTION);
            const basePrompt = promptParts.filter(Boolean).map(part => part.toString().trim()).filter(Boolean).join('\n');
            const limitedBasePrompt = truncatePrompt(basePrompt);
            const englishPrompt = await translateToEnglish(limitedBasePrompt || basePrompt);
            const finalPrompt = buildFinalImagePrompt(limitedBasePrompt, englishPrompt);
            const res = await fetch('/.netlify/functions/gpt-handler', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ prompt: finalPrompt })
            });

            let data;
            try {
                data = await res.json();
            } catch (_) {
                throw new Error('서버 응답을 파싱하지 못했습니다.');
            }

            if (!res.ok) {
                const message = data.error?.message || data.error || 'GPT Image API Error';
                throw new Error(message);
            }

            const base64 = data.data?.[0]?.b64_json;
            if (!base64) {
                throw new Error('이미지 데이터가 없습니다.');
            }

            return `data:image/webp;base64,${base64}`;
        }

        // 수동 책 만들기 시작
        function startManualBookCreation() {
            buildBookViewer();
            document.getElementById('book-viewer-page').classList.remove('hidden');
        }

        // 책 뷰어 UI 구성
        function buildBookViewer() {
            const viewer = document.getElementById("book-viewer");
            viewer.innerHTML = ""; // 기존 내용 초기화

            totalBookSpreads = 3; // 기본 3장 (표지, 등장인물, 이야기 시작)
            
            // 0. 표지 페이지
            const spread0 = `
                <div id="spread-0" class="book-spread book-viewer" data-page-type="cover">
                    <div class="book-page bg-white border-r border-gray-300">
                        <div style="width: 80%; text-align: center;">
                            <div class="text-box mb-4">
                                <h1 class="text-3xl font-bold editable-text book-title-sync" contenteditable="true">제목을 입력하세요</h1>
                            </div>
                            <div class="text-box inline-block">
                                <p class="book-author-sync" contenteditable="false">글쓴이</p>
                            </div>
                        </div>
                    </div>
                    <div class="book-page bg-gray-200">
                        <div class="absolute top-6 left-6">
                            <div class="text-sm font-semibold mb-1 text-gray-600">제목</div>
                            <div class="text-xl p-2 bg-white bg-opacity-80 rounded shadow editable-text book-title-sync" contenteditable="true">제목을 입력하세요</div>
                        </div>
                        <div class="absolute bottom-4 right-4 text-box">
                            <p class="book-author-sync" contenteditable="false">글쓴이</p>
                        </div>
                    </div>
                </div>
            `;

            // 1. 등장인물 소개 페이지
            const spread1 = `
                <div id="spread-1" class="book-spread book-viewer" data-page-type="character">
                    <!-- 왼쪽 페이지 (1) -->
                    <div class="book-page bg-white border-r border-gray-300">
                        <h2 class="absolute top-6 text-2xl font-bold text-gray-700">등장인물 소개</h2>
                        <div class="w-full h-full flex flex-col items-center justify-center pt-16">
                           <div class="w-full h-1/2 bg-gray-200 mb-4 rounded flex items-center justify-center text-gray-400 character-image-box" style="background-size: cover; background-position: center;">그림 1</div>
                           <div class="editable-text text-xl font-bold" contenteditable="true">이름 1</div>
                           <textarea class="manual-text-area mt-2 h-1/4 text-sm" placeholder="어떤 인물인지 설명해주세요."></textarea>
                        </div>
                        <div class="page-number" style="left: 0.5rem;">1</div>
                    </div>
                    <!-- 오른쪽 페이지 (2) -->
                    <div class="book-page bg-white">
                         <h2 class="absolute top-6 text-2xl font-bold text-gray-700 opacity-0">등장인물 소개</h2>
                         <div class="w-full h-full flex flex-col items-center justify-center pt-16">
                           <div class="w-full h-1/2 bg-gray-200 mb-4 rounded flex items-center justify-center text-gray-400 character-image-box" style="background-size: cover; background-position: center;">그림 2</div>
                           <div class="editable-text text-xl font-bold" contenteditable="true">이름 2</div>
                           <textarea class="manual-text-area mt-2 h-1/4 text-sm" placeholder="어떤 인물인지 설명해주세요."></textarea>
                        </div>
                        <div class="page-number" style="right: 0.5rem;">2</div>
                    </div>
                </div>
            `;
            
            // 2. 이야기 시작 페이지
            const spread2 = `
                 <div id="spread-2" class="book-spread book-viewer" data-page-type="story">
                    <!-- 왼쪽 페이지 (3) -->
                    <div class="book-page bg-gray-200 border-r border-gray-300 flex items-center justify-center">
                        <span class="text-gray-400">그림이 생성될 곳</span>
                        <div class="page-number" style="left: 0.5rem;">3</div>
                    </div>
                    <!-- 오른쪽 페이지 (4) -->
                    <div class="book-page bg-white">
                        <textarea class="manual-text-area" placeholder="여기에 이야기를 입력하세요..."></textarea>
                        <div class="page-number" style="right: 0.5rem;">4</div>
                    </div>
                </div>
            `;

            // 네비게이션 버튼 및 페이지 액션 버튼 컨테이너
            const navButtons = `
                <button id="prev-page-btn" onclick="changeBookPage(-1)" class="page-nav left-2">‹</button>
                <button id="next-page-btn" onclick="changeBookPage(1)" class="page-nav right-2">›</button>
                <div id="page-action-buttons" class="absolute top-4 right-4 flex gap-2 z-10"></div>
            `;

            viewer.innerHTML = spread0 + spread1 + spread2 + navButtons;

            setupAllRegenerateButtons();

            bookCurrentPage = 0;
            document.getElementById('spread-0').classList.add('active'); // 첫 페이지 활성화
            updateBookView();
            // 빌드 후 로그인한 사용자의 이름을 저자 영역에 반영합니다.
            window.syncBookAuthor();
        }
        
        // ID 및 페이지 번호 재정렬
        function updatePageNumbersAndIDs() {
            const spreads = document.querySelectorAll("#book-viewer .book-spread");
            spreads.forEach((spread, index) => {
                spread.id = `spread-${index}`;

                // 표지(index 0)에는 페이지 번호 없음
                if (index > 0) {
                    const leftPageNumEl = spread.querySelector('.page-number[style*="left"]');
                    const rightPageNumEl = spread.querySelector('.page-number[style*="right"]');

                    if (leftPageNumEl) {
                        leftPageNumEl.textContent = (index - 1) * 2 + 1;
                    }
                    if (rightPageNumEl) {
                        rightPageNumEl.textContent = (index - 1) * 2 + 2;
                    }
                }
            });
        }
        
        // 등장인물 페이지 추가
        function addCharacterPage() {
            const viewer = document.getElementById("book-viewer");
            const characterSpreads = viewer.querySelectorAll('.book-spread[data-page-type="character"]');

            const existingCharacters = viewer.querySelectorAll('.character-image-box').length;
            const charNum1 = existingCharacters + 1;
            const charNum2 = existingCharacters + 2;

            const newSpread = document.createElement("div");
            newSpread.className = "book-spread book-viewer";
            newSpread.dataset.pageType = "character";

            newSpread.innerHTML = `
                <div class="book-page bg-white border-r border-gray-300">
                    <h2 class="absolute top-6 text-2xl font-bold text-gray-700">등장인물 소개</h2>
                    <div class="w-full h-full flex flex-col items-center justify-center pt-16">
                       <div class="w-full h-1/2 bg-gray-200 mb-4 rounded flex items-center justify-center text-gray-400 character-image-box" style="background-size: cover; background-position: center;">그림 ${charNum1}</div>
                       <div class="editable-text text-xl font-bold" contenteditable="true">이름 ${charNum1}</div>
                       <textarea class="manual-text-area mt-2 h-1/4 text-sm" placeholder="어떤 인물인지 설명해주세요."></textarea>
                    </div>
                    <div class="page-number" style="left: 0.5rem;"></div>
                </div>
                <div class="book-page bg-white">
                     <h2 class="absolute top-6 text-2xl font-bold text-gray-700 opacity-0">등장인물 소개</h2>
                     <div class="w-full h-full flex flex-col items-center justify-center pt-16">
                       <div class="w-full h-1/2 bg-gray-200 mb-4 rounded flex items-center justify-center text-gray-400 character-image-box" style="background-size: cover; background-position: center;">그림 ${charNum2}</div>
                       <div class="editable-text text-xl font-bold" contenteditable="true">이름 ${charNum2}</div>
                       <textarea class="manual-text-area mt-2 h-1/4 text-sm" placeholder="어떤 인물인지 설명해주세요."></textarea>
                    </div>
                    <div class="page-number" style="right: 0.5rem;"></div>
                </div>
            `;

            if (characterSpreads.length === 0) {
                const cover = document.getElementById('spread-0');
                cover.after(newSpread);
            } else {
                const lastCharacterSpread = characterSpreads[characterSpreads.length - 1];
                lastCharacterSpread.after(newSpread);
            }
            setupRegenerateButtonsForSpread(newSpread);
            updateRegenerateButtonsVisibility();
            totalBookSpreads++;

            updatePageNumbersAndIDs();

            const newPageIndex = Array.from(viewer.querySelectorAll('.book-spread')).indexOf(newSpread);
            bookCurrentPage = newPageIndex;
            updateBookView();
        }

        // 이야기 페이지 추가
        function addManualPage() {
            const viewer = document.getElementById("book-viewer");
            const newSpread = document.createElement("div");
            newSpread.className = "book-spread book-viewer";
            newSpread.dataset.pageType = 'story';
            
            newSpread.innerHTML = `
                <div class="book-page bg-gray-200 border-r border-gray-300 flex items-center justify-center">
                    <span class="text-gray-400">그림이 생성될 곳</span>
                    <div class="page-number" style="left: 0.5rem;"></div>
                </div>
                <div class="book-page bg-white">
                    <textarea class="manual-text-area" placeholder="여기에 이야기를 입력하세요..."></textarea>
                    <div class="page-number" style="right: 0.5rem;"></div>
                </div>
            `;
            
            const prevButton = document.getElementById('prev-page-btn');
            viewer.insertBefore(newSpread, prevButton);

            setupRegenerateButtonsForSpread(newSpread);
            updateRegenerateButtonsVisibility();

            totalBookSpreads++;
            updatePageNumbersAndIDs();

            bookCurrentPage = totalBookSpreads - 1;
            updateBookView();
        }

        // 현재 페이지 삭제
        function deleteCurrentPage() {
            const currentSpread = document.getElementById(`spread-${bookCurrentPage}`);
            if (!currentSpread) return;
            const type = currentSpread.dataset.pageType;
            if (type === 'cover') {
                showNotification("표지는 삭제할 수 없습니다.");
                return;
            }
            if (type === 'character') {
                // 등장인물 페이지는 모두 삭제 가능
            }
            if (type === 'story') {
                const storySpreads = Array.from(document.querySelectorAll('#book-viewer .book-spread[data-page-type="story"]'));
                if (storySpreads.indexOf(currentSpread) === 0) {
                    showNotification("기본 줄거리 페이지는 삭제할 수 없습니다.");
                    return;
                }
            }
            currentSpread.remove();
            totalBookSpreads--;
            bookCurrentPage = Math.max(0, Math.min(bookCurrentPage, totalBookSpreads - 1));
            updatePageNumbersAndIDs();
            updateBookView();
            showNotification("페이지가 삭제되었습니다.");
        }

        // 책 초안 저장
        async function saveBookDraft() {
            if (!bookCode || !auth?.currentUser) {
                showNotification("코드가 없어 저장할 수 없습니다.");
                return;
            }
            const btn = document.getElementById('save-book-btn');
            btn.disabled = true;
            btn.textContent = '저장 중...';
            try {
                const data = {
                    title: document.querySelector('#spread-0 .book-title-sync')?.textContent.trim() || '',
                    author: window.bookAuthorName || window.authorName || '',
                    updatedAt: serverTimestamp(),
                    totalSpreads: document.querySelectorAll('#book-viewer .book-spread').length,
                    characterSpreadCount: document.querySelectorAll('#book-viewer .book-spread[data-page-type="character"]').length,
                    storySpreadCount: document.querySelectorAll('#book-viewer .book-spread[data-page-type="story"]').length,
                };

                  const uploads = [];

                  async function uploadDataUrl(imgRef, dataUrl) {
                      const res = await fetch(dataUrl);
                      const blob = await res.blob();
                      return uploadBytes(imgRef, blob);
                  }

                  // 표지 이미지 (1장 오른쪽 배경)
                  const coverPage = document.querySelector('#spread-0 .book-page:nth-child(2)');
                  if (coverPage) {
                    const bg = coverPage.style.backgroundImage;
                    const match = bg.match(/url\(["']?(data:image\/[^"')]+)["']?\)/);
                    if (match) {
                        const dataUrl = match[1];
                        const existingName = coverPage.dataset.imageName || '';
                        const extension = existingName.split('.').pop();
                        const finalExt = existingName && extension ? extension : getExtensionFromDataUrl(dataUrl);
                        const fileName = existingName || `cover.${finalExt}`;
                        coverPage.dataset.imageName = fileName;
                        const imgRef = storageRef(storage, `Book/${bookCode}/${fileName}`);
                        uploads.push(uploadDataUrl(imgRef, dataUrl));
                        data.coverImage = fileName;
                    } else if (coverPage.dataset.imageName) {
                        data.coverImage = coverPage.dataset.imageName;
                    }
                  }

                const coverSpread = document.querySelector('#spread-0');
                if (coverSpread) {
                    data.coverPrompt = coverSpread.dataset.prompt || '';
                }

                  // 등장인물 정보 저장
                  const characterPages = document.querySelectorAll('.book-spread[data-page-type="character"] .book-page');
                  characterPages.forEach((page, idx) => {
                      const charIndex = idx + 1;
                      const imgBox = page.querySelector('.character-image-box');
                      if (imgBox) {
                          const bg = imgBox.style.backgroundImage;
                          const match = bg.match(/url\(["']?(data:image\/[^"')]+)["']?\)/);
                          if (match) {
                              const dataUrl = match[1];
                              const existingName = imgBox.dataset.imageName || '';
                              const existingExt = existingName.split('.').pop();
                              const finalExt = existingName && existingExt ? existingExt : getExtensionFromDataUrl(dataUrl);
                              const imageName = existingName || `character${charIndex}.${finalExt}`;
                              imgBox.dataset.imageName = imageName;
                              const imgRef = storageRef(storage, `Book/${bookCode}/${imageName}`);
                              uploads.push(uploadDataUrl(imgRef, dataUrl));
                              data[`character${charIndex}Image`] = imageName;
                          } else if (imgBox.dataset.imageName) {
                              data[`character${charIndex}Image`] = imgBox.dataset.imageName;
                          }
                      }

                      const nameEl = page.querySelector('.editable-text');
                      if (nameEl) {
                          data[`character${charIndex}Name`] = nameEl.textContent.trim();
                      }
                      const descEl = page.querySelector('textarea.manual-text-area');
                      if (descEl) {
                          data[`character${charIndex}Desc`] = descEl.value;
                      }
                  });

                  const characterSpreads = document.querySelectorAll('.book-spread[data-page-type="character"]');
                  characterSpreads.forEach((spread, idx) => {
                      const base = idx * 2 + 1;
                      data[`character${base}Prompt`] = spread.dataset.promptLeft || '';
                      data[`character${base + 1}Prompt`] = spread.dataset.promptRight || '';
                  });

                  // 줄거리 저장
                  const storySpreads = document.querySelectorAll('.book-spread[data-page-type="story"]');
                  storySpreads.forEach((spread, idx) => {
                      const storyIndex = idx + 1;
                    const imagePage = spread.querySelector('.book-page:first-child');
                    if (imagePage) {
                        const bg = imagePage.style.backgroundImage;
                        const match = bg.match(/url\(["']?(data:image\/[^"')]+)["']?\)/);
                        if (match) {
                            const dataUrl = match[1];
                            const existingName = imagePage.dataset.imageName || '';
                            const existingExt = existingName.split('.').pop();
                            const finalExt = existingName && existingExt ? existingExt : getExtensionFromDataUrl(dataUrl);
                            const imageName = existingName || `story${storyIndex}.${finalExt}`;
                            imagePage.dataset.imageName = imageName;
                            const imgRef = storageRef(storage, `Book/${bookCode}/${imageName}`);
                            uploads.push(uploadDataUrl(imgRef, dataUrl));
                            data[`story${storyIndex}Image`] = imageName;
                        } else if (imagePage.dataset.imageName) {
                            data[`story${storyIndex}Image`] = imagePage.dataset.imageName;
                        }
                    }
                      const textPage = spread.querySelector('.book-page:last-child textarea.manual-text-area');
                      if (textPage) {
                          data[`story${storyIndex}Text`] = textPage.value;
                      }
                      data[`story${storyIndex}Prompt`] = spread.dataset.prompt || '';
                  });

                await Promise.all(uploads);

                await setDoc(doc(db, 'Book', bookCode), data, { merge: true });

                const myBooksRef = collection(db, `users/${bookOwnerUid}/myBooks`);
                const q = query(myBooksRef, where('bookId', '==', bookCode));
                const snap = await getDocs(q);
                snap.forEach(docSnap => updateDoc(docSnap.ref, { title: data.title }));

                showNotification('저장되었습니다!');
            } catch (err) {
                console.error(err);
                showNotification('저장 실패: ' + err.message);
            } finally {
                btn.textContent = '저장하기';
                btn.disabled = false;
            }
        }

        // 도서관 등록
        async function registerToLibrary() {
            if (!bookCode || !auth?.currentUser) {
                showNotification('등록할 책이 없습니다.');
                return;
            }

            const btn = document.getElementById('register-library-btn');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = '등록 중...';

            try {
                await updateDoc(doc(db, 'Book', bookCode), {
                    isPublic: true,
                    publishedAt: serverTimestamp()
                });
                showNotification('도서관에 등록되었습니다!');
                bookIsPublic = true;
                setViewMode(true);
                await loadLibraryBooks();
            } catch (error) {
                console.error('도서관 등록 실패:', error);
                showNotification('도서관 등록 실패: ' + error.message);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        function setViewMode(mode) {
            isViewMode = mode;
            applyViewMode();
            updateBookView();
        }

        function applyViewMode() {
            const gptBtn = document.getElementById('generate-images-gpt-btn');
            const generateBtn = document.getElementById('generate-images-btn');
            const saveBtn = document.getElementById('save-book-btn');
            const registerBtn = document.getElementById('register-library-btn');
            const editBtn = document.getElementById('edit-book-btn');
            const pdfBtn = document.getElementById('save-book-pdf-btn');
            const promptWrapper = document.getElementById('page-prompt-wrapper');
            const actionContainer = document.getElementById('page-action-buttons');
            const likeSection = document.getElementById('book-like-section');
            const commentsSection = document.getElementById('book-comments-section');

            if (gptBtn) gptBtn.classList.add('hidden');

            if (isViewMode) {
                if (generateBtn) generateBtn.classList.add('hidden');
                if (saveBtn) saveBtn.classList.add('hidden');
                if (registerBtn) registerBtn.classList.add('hidden');
                if (promptWrapper) promptWrapper.classList.add('hidden');
                if (actionContainer) actionContainer.classList.add('hidden');
                if (pdfBtn) pdfBtn.classList.remove('hidden');
                if (likeSection) likeSection.classList.remove('hidden');
                if (commentsSection) commentsSection.classList.remove('hidden');
                if (canEditBook) {
                    if (editBtn) editBtn.classList.remove('hidden');
                } else if (editBtn) {
                    editBtn.classList.add('hidden');
                }
                document.querySelectorAll('#book-viewer textarea').forEach(t => t.setAttribute('readonly', true));
                document.querySelectorAll('#book-viewer .editable-text').forEach(e => e.setAttribute('contenteditable', 'false'));
            } else {
                if (generateBtn) {
                    if (imagesGenerated) {
                        generateBtn.classList.add('hidden');
                    } else {
                        generateBtn.classList.remove('hidden');
                    }
                }
                if (saveBtn) saveBtn.classList.remove('hidden');
                if (!bookIsPublic && registerBtn) registerBtn.classList.remove('hidden');
                if (promptWrapper) promptWrapper.classList.remove('hidden');
                if (actionContainer) actionContainer.classList.remove('hidden');
                if (pdfBtn) pdfBtn.classList.add('hidden');
                if (likeSection) likeSection.classList.add('hidden');
                if (commentsSection) commentsSection.classList.add('hidden');
                if (editBtn) editBtn.classList.add('hidden');
                document.querySelectorAll('#book-viewer textarea').forEach(t => t.removeAttribute('readonly'));
                document.querySelectorAll('#book-viewer .editable-text').forEach(e => e.setAttribute('contenteditable', 'true'));
            }
            updateRegenerateButtonsVisibility();
        }

        function enableEditMode() {
            setViewMode(false);
        }

        // 책 완성 (그림 생성)
        async function completeManualBook() {
            const generateBtn = document.getElementById("generate-images-btn");
            const registerBtn = document.getElementById('register-library-btn');
            const savePdfBtn = document.getElementById('save-book-pdf-btn');
            
            const originalGenerateText = "한번에 그림 생성하기";

            generateBtn.textContent = "생성 중...";
            generateBtn.disabled = true;

            try {
                // 등장인물 컨텍스트 수집 및 이미지 생성
                const charSpreads = document.querySelectorAll('.book-spread[data-page-type="character"]');
                const characterContextParts = [];
                for (const charSpread of charSpreads) {
                    const charImageBoxes = charSpread.querySelectorAll('.character-image-box');
                    const prompts = [charSpread.dataset.promptLeft, charSpread.dataset.promptRight];
                    const charDescriptions = charSpread.querySelectorAll('textarea');
                    const charNames = charSpread.querySelectorAll('.editable-text');

                    for (let i = 0; i < charImageBoxes.length; i++) {
                        let prompt = prompts[i];
                        if (!prompt) {
                            const desc = charDescriptions[i]?.value || '';
                            const name = charNames[i]?.textContent || '';
                            if (desc || name) {
                                prompt = `${name}, ${desc}`.trim();
                            }
                        }
                        if (prompt) {
                            characterContextParts.push(prompt);
                            const charPrompt = `${prompt}, 동일한 파스텔 색감과 몽환적인 분위기를 지닌 단일 캐릭터 장면`;
                            const charImage = await generateImageForParagraph(charPrompt, '');
                            charImageBoxes[i].style.backgroundImage = `url('${charImage}')`;
                            charImageBoxes[i].textContent = '';
                        }
                    }
                    setupRegenerateButtonsForSpread(charSpread);
                }
                const characterContext = characterContextParts.join('\n');

                // 표지 이미지 생성
                const coverSpread = document.querySelector('#spread-0');
                const coverPrompt = coverSpread?.dataset.prompt || document.querySelector("#spread-0 .book-title-sync").textContent;
                const coverImage = await generateImageForParagraph(coverPrompt, characterContext);
                document.querySelector("#spread-0 .book-page:last-child").style.backgroundImage = `url('${coverImage}')`;

                // 각 이야기 페이지 이미지 생성
                const storySpreads = document.querySelectorAll('.book-spread[data-page-type="story"]');
                let previousStoryText = '';
                let previousStoryPrompt = '';
                for (const spread of storySpreads) {
                    const storyText = (spread.querySelector("textarea")?.value || '').trim();
                    const extra = (spread.dataset.prompt || '').trim();
                    const promptParts = [storyText, extra].filter(Boolean);
                    const imagePage = spread.querySelector(".book-page:first-child");
                    const pageNumHTML = imagePage.querySelector('.page-number')?.outerHTML || '';

                    if (promptParts.length === 0) {
                        setupRegenerateButtonsForSpread(spread);
                        continue;
                    }

                    const prompt = promptParts.join('\n');
                    const contextParts = [];
                    if (characterContext) {
                        contextParts.push(`등장인물 정보: ${characterContext}`);
                    }
                    if (previousStoryText) {
                        contextParts.push(`이전 줄거리: ${previousStoryText}`);
                    }
                    if (previousStoryPrompt) {
                        contextParts.push(`이전 추가 설명: ${previousStoryPrompt}`);
                    }
                    const combinedContext = contextParts.join('\n');

                    try {
                        const imageUrl = await generateImageForParagraph(prompt, combinedContext);
                        imagePage.style.backgroundImage = `url('${imageUrl}')`;
                        imagePage.innerHTML = pageNumHTML;
                        previousStoryText = storyText;
                        previousStoryPrompt = extra;
                    } finally {
                        setupRegenerateButtonsForSpread(spread);
                    }
                }
                showNotification("책이 완성되었습니다! 이제 도서관에 등록할 수 있습니다.");

                // 그림 생성 버튼은 영구적으로 비활성화하고 숨기기
                generateBtn.disabled = true;
                generateBtn.classList.add('hidden');
                imagesGenerated = true;
                imageGenerationMethod = 'stability';

                // PDF 저장 및 도서관 등록 버튼 보이기 및 활성화
                if(savePdfBtn) {
                    savePdfBtn.classList.remove('hidden');
                }
                if(registerBtn) {
                    registerBtn.classList.remove('hidden');
                    registerBtn.disabled = false;
                }

            } catch (error) {
                console.error("수동 책 완성 오류:", error);
                showNotification(`그림 생성 중 오류가 발생했습니다: ${error.message}`);
                
                // 실패 시 그림 생성 버튼 원상 복구
                generateBtn.textContent = originalGenerateText;
                generateBtn.disabled = false;
            }
            updateRegenerateButtonsVisibility();
        }

        async function completeManualBookGPT() {
            const gptBtn = document.getElementById("generate-images-gpt-btn");
            const stabilityBtn = document.getElementById("generate-images-btn");
            const registerBtn = document.getElementById('register-library-btn');
            const savePdfBtn = document.getElementById('save-book-pdf-btn');

            const originalText = "GPT 사진 만들기/1토큰";

            gptBtn.textContent = "생성 중...";
            gptBtn.disabled = true;
            if (stabilityBtn) stabilityBtn.disabled = true;

            try {
                const userRef = doc(db, 'users', bookAuthorUid);
                const userDoc = await getDoc(userRef);
                const tokens = Number(userDoc.data()?.aeduTokens) || 0;
                if (tokens < 1) {
                    alert('에이두 토큰이 부족합니다.');
                    gptBtn.textContent = originalText;
                    gptBtn.disabled = false;
                    if (stabilityBtn) stabilityBtn.disabled = false;
                    return;
                }
                await updateDoc(userRef, { aeduTokens: increment(-1) });
                await updateUserInfo();

                // 등장인물 컨텍스트 수집 및 이미지 생성
                const charSpreads = document.querySelectorAll('.book-spread[data-page-type="character"]');
                const characterContextParts = [];
                for (const charSpread of charSpreads) {
                    const charImageBoxes = charSpread.querySelectorAll('.character-image-box');
                    const prompts = [charSpread.dataset.promptLeft, charSpread.dataset.promptRight];
                    const charDescriptions = charSpread.querySelectorAll('textarea');
                    const charNames = charSpread.querySelectorAll('.editable-text');

                    for (let i = 0; i < charImageBoxes.length; i++) {
                        let prompt = prompts[i];
                        if (!prompt) {
                            const desc = charDescriptions[i]?.value || '';
                            const name = charNames[i]?.textContent || '';
                            if (desc || name) {
                                prompt = `${name}, ${desc}`.trim();
                            }
                        }
                        if (prompt) {
                            characterContextParts.push(prompt);
                            const charPrompt = `${prompt}, 동일한 파스텔 색감과 몽환적인 분위기를 지닌 단일 캐릭터 장면`;
                            const charImage = await generateImageForParagraphGPT(charPrompt, '');
                            charImageBoxes[i].style.backgroundImage = `url('${charImage}')`;
                            charImageBoxes[i].textContent = '';
                        }
                    }
                    setupRegenerateButtonsForSpread(charSpread);
                }
                const characterContext = characterContextParts.join('\n');

                // 표지 이미지 생성
                const coverSpread = document.querySelector('#spread-0');
                const coverPrompt = coverSpread?.dataset.prompt || document.querySelector("#spread-0 .book-title-sync").textContent;
                const coverImage = await generateImageForParagraphGPT(coverPrompt, characterContext);
                document.querySelector("#spread-0 .book-page:last-child").style.backgroundImage = `url('${coverImage}')`;

                // 각 이야기 페이지 이미지 생성
                const storySpreads = document.querySelectorAll('.book-spread[data-page-type="story"]');
                let previousStoryText = '';
                let previousStoryPrompt = '';
                for (const spread of storySpreads) {
                    const storyText = (spread.querySelector("textarea")?.value || '').trim();
                    const extra = (spread.dataset.prompt || '').trim();
                    const promptParts = [storyText, extra].filter(Boolean);
                    const imagePage = spread.querySelector(".book-page:first-child");
                    const pageNumHTML = imagePage.querySelector('.page-number')?.outerHTML || '';

                    if (promptParts.length === 0) {
                        setupRegenerateButtonsForSpread(spread);
                        continue;
                    }

                    const prompt = promptParts.join('\n');
                    const contextParts = [];
                    if (characterContext) {
                        contextParts.push(`등장인물 정보: ${characterContext}`);
                    }
                    if (previousStoryText) {
                        contextParts.push(`이전 줄거리: ${previousStoryText}`);
                    }
                    if (previousStoryPrompt) {
                        contextParts.push(`이전 추가 설명: ${previousStoryPrompt}`);
                    }
                    const combinedContext = contextParts.join('\n');

                    try {
                        const imageUrl = await generateImageForParagraphGPT(prompt, combinedContext);
                        imagePage.style.backgroundImage = `url('${imageUrl}')`;
                        imagePage.innerHTML = pageNumHTML;
                        previousStoryText = storyText;
                        previousStoryPrompt = extra;
                    } finally {
                        setupRegenerateButtonsForSpread(spread);
                    }
                }
                showNotification("책이 완성되었습니다! 이제 도서관에 등록할 수 있습니다.");

                gptBtn.disabled = true;

                if (savePdfBtn) {
                    savePdfBtn.classList.remove('hidden');
                }
                if (registerBtn) {
                    registerBtn.classList.remove('hidden');
                    registerBtn.disabled = false;
                }

                imageGenerationMethod = 'gpt';

            } catch (error) {
                console.error("수동 책 완성 오류:", error);
                showNotification(`그림 생성 중 오류가 발생했습니다: ${error.message}`);

                gptBtn.textContent = originalText;
                gptBtn.disabled = false;
                if (stabilityBtn) stabilityBtn.disabled = false;
            }
            updateRegenerateButtonsVisibility();
        }
        
        // 페이지 넘기기
        function changeBookPage(direction) {
            bookCurrentPage = Math.max(0, Math.min(bookCurrentPage + direction, totalBookSpreads - 1));
            updateBookView();
        }

        function renderPromptArea(spread) {
            const wrapper = document.getElementById('page-prompt-wrapper');
            if (!wrapper) return;
            wrapper.innerHTML = '';
            if (!spread) return;

            const type = spread.dataset.pageType;

            if (type === 'cover') {
                wrapper.innerHTML = `
            <label class="block text-lg font-semibold text-gray-700 mb-2">표지 사진을 어떻게 만들까요?</label>
            <textarea id="page-prompt-input" class="w-full p-3 border border-gray-300 rounded-lg" rows="3"></textarea>
        `;
                const input = wrapper.querySelector('#page-prompt-input');
                input.value = spread.dataset.prompt || '';
                input.addEventListener('input', (e) => {
                    spread.dataset.prompt = e.target.value;
                });
            } else if (type === 'character') {
                wrapper.innerHTML = `
            <div class="flex gap-4">
                <div class="flex-1">
                    <label class="block text-lg font-semibold text-gray-700 mb-2 text-left">등장인물을 어떻게 만들까요?</label>
                    <textarea id="page-prompt-left" class="w-full p-3 border border-gray-300 rounded-lg" rows="2"></textarea>
                </div>
                <div class="flex-1 text-right">
                    <label class="block text-lg font-semibold text-gray-700 mb-2 text-right">등장인물을 어떻게 만들까요?</label>
                    <textarea id="page-prompt-right" class="w-full p-3 border border-gray-300 rounded-lg" rows="2"></textarea>
                </div>
            </div>
        `;
                const left = wrapper.querySelector('#page-prompt-left');
                const right = wrapper.querySelector('#page-prompt-right');
                left.value = spread.dataset.promptLeft || '';
                right.value = spread.dataset.promptRight || '';
                left.addEventListener('input', (e) => {
                    spread.dataset.promptLeft = e.target.value;
                });
                right.addEventListener('input', (e) => {
                    spread.dataset.promptRight = e.target.value;
                });
            } else if (type === 'story') {
                wrapper.innerHTML = `
            <label class="block text-lg font-semibold text-gray-700 mb-2">이 페이지의 줄거리 사진을 어떻게 만들까요?</label>
            <textarea id="page-prompt-input" class="w-full p-3 border border-gray-300 rounded-lg" rows="3"></textarea>
        `;
                const input = wrapper.querySelector('#page-prompt-input');
                input.value = spread.dataset.prompt || '';
                input.addEventListener('input', (e) => {
                    spread.dataset.prompt = e.target.value;
                });
            }
        }

        function updateBookView() {
    document.querySelectorAll(".book-spread").forEach((spread, index) => {
        spread.classList.toggle("active", index === bookCurrentPage);
    });
    document.getElementById("prev-page-btn").style.display = bookCurrentPage === 0 ? "none" : "block";
    document.getElementById("next-page-btn").style.display = bookCurrentPage >= totalBookSpreads - 1 ? "none" : "block";

    const actionContainer = document.getElementById('page-action-buttons');
    actionContainer.innerHTML = '';
    const currentSpread = document.getElementById(`spread-${bookCurrentPage}`);
    if (!currentSpread) return;
    const type = currentSpread.dataset.pageType;

    if (!isViewMode) {
        if (type === 'story') {
            const storySpreads = Array.from(document.querySelectorAll('#book-viewer .book-spread[data-page-type="story"]'));
            const storyIndex = storySpreads.indexOf(currentSpread);
            const charSpreads = document.querySelectorAll('#book-viewer .book-spread[data-page-type="character"]');
            let buttons = '';
            if (charSpreads.length === 0) {
                buttons += `<button onclick="addCharacterPage()" class="bg-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-600">+ 등장인물 추가</button>`;
            }
            buttons += `<button onclick="addManualPage()" class="bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-cyan-600">+ 페이지 추가</button>`;
            if (storyIndex > 0) {
                buttons += `<button onclick="deleteCurrentPage()" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600">페이지 삭제</button>`;
            }
            actionContainer.innerHTML = buttons;
        } else if (type === 'character') {
            let buttons = `<button onclick="addCharacterPage()" class="bg-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-600">+ 등장인물 추가</button>`;
            buttons += `<button onclick="deleteCurrentPage()" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600">페이지 삭제</button>`;
            actionContainer.innerHTML = buttons;
        } else if (type === 'cover') {
            const charSpreads = document.querySelectorAll('#book-viewer .book-spread[data-page-type="character"]');
            if (charSpreads.length === 0) {
                actionContainer.innerHTML = `<button onclick="addCharacterPage()" class="bg-sky-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-600">+ 등장인물 추가</button>`;
            }
        }
        renderPromptArea(currentSpread);
    } else {
        const wrapper = document.getElementById('page-prompt-wrapper');
        if (wrapper) wrapper.innerHTML = '';
    }
}

        // PDF로 다운로드
        async function downloadBookAsPDF() {
            const button = document.getElementById('save-book-pdf-btn');
            button.textContent = "PDF 생성 중...";
            button.disabled = true;

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({ orientation: "landscape", unit: "mm", format: "a4" });
            const spreads = document.querySelectorAll(".book-spread");
            const originalPage = bookCurrentPage;
            const previouslyVisibleButtons = Array.from(document.querySelectorAll('.image-action-btn.visible'));
            previouslyVisibleButtons.forEach(btn => btn.classList.remove('visible'));

            const blobToDataUrl = (blob) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(blob);
            });

            const originalBgs = [];
            const bgElements = document.querySelectorAll('.book-page, .character-image-box');
            for (const el of bgElements) {
                const bg = el.style.backgroundImage;
                const match = bg.match(/url\(["']?(.*?)["']?\)/);
                if (match && !match[1].startsWith('data:')) {
                    let dataUrl = null;
                    const imageName = el.dataset?.imageName;
                    if (imageName && bookCode) {
                        try {
                            const fileRef = storageRef(storage, `Book/${bookCode}/${imageName}`);
                            const blob = await getBlob(fileRef);
                            dataUrl = await blobToDataUrl(blob);
                        } catch (err) {
                            console.error('Failed to load image from storage for PDF', err);
                        }
                    }
                    if (dataUrl) {
                        originalBgs.push({ el, bg });
                        el.style.backgroundImage = `url('${dataUrl}')`;
                    }
                }
            }

            for (let i = 0; i < spreads.length; i++) {
                if (i > 0) pdf.addPage("a4", "l");

                document.querySelectorAll(".book-spread").forEach(s => s.classList.remove("active"));
                spreads[i].classList.add("active");
                
                // --- 텍스트 줄바꿈 처리를 위한 수정 ---
                const textarea = spreads[i].querySelector('textarea.manual-text-area');
                let tempDiv = null;

                if (textarea) {
                    // 1. textarea를 숨기고 똑같이 생긴 div를 만듭니다.
                    tempDiv = document.createElement('div');
                    // 클래스와 스타일을 복사하여 모양을 최대한 똑같이 만듭니다.
                    tempDiv.className = textarea.className;
                    tempDiv.style.cssText = window.getComputedStyle(textarea).cssText;
                    
                    // 2. textarea의 줄바꿈(\n)을 <br> 태그로 변환합니다.
                    tempDiv.innerHTML = textarea.value.replace(/\n/g, '<br>');
                    
                    // 3. textarea를 숨기고 그 자리에 임시 div를 삽입합니다.
                    textarea.style.display = 'none';
                    textarea.parentNode.insertBefore(tempDiv, textarea);
                }
                // --- 수정 끝 ---

                await new Promise(res => setTimeout(res, 100));

                const canvas = await html2canvas(spreads[i], {
                    scale: 2,
                    useCORS: true,
                    backgroundColor: "#ffffff"
                });
                pdf.addImage(canvas.toDataURL("image/png"), "PNG", 0, 0, 297, 210);

                // --- 원상 복구를 위한 수정 ---
                if (tempDiv) {
                    // 4. PDF 생성이 끝나면 임시 div를 제거하고 원래 textarea를 다시 보여줍니다.
                    tempDiv.remove();
                    textarea.style.display = '';
                }
                // --- 수정 끝 ---
            }

            pdf.save(`${document.querySelector(".book-title-sync").textContent || '나만의_동화책'}.pdf`);

            document.querySelectorAll(".book-spread").forEach(s => s.classList.remove("active"));
            if (spreads[originalPage]) spreads[originalPage].classList.add("active");

            originalBgs.forEach(({ el, bg }) => {
                el.style.backgroundImage = bg;
            });

            previouslyVisibleButtons.forEach(btn => btn.classList.add('visible'));

            button.textContent = "PDF 저장";
            button.disabled = false;
        }

        // 제목 및 글쓴이 동기화 이벤트 리스너
        document.addEventListener('input', e => {
            const target = e.target;
            if (target.classList.contains('book-title-sync')) {
                const newContent = target.textContent;
                document.querySelectorAll('.book-title-sync').forEach(el => {
                    if (el !== target) {
                        el.textContent = newContent;
                    }
                });
            }
        });

        // 페이지 로드 시 초기화는 인증 후 처리됩니다.
        
        // 단어 클릭 시 TTS 이벤트 리스너
        document.addEventListener("click", e => {
            if (e.target.classList.contains("tts-word")) {
                speak(e.target.textContent.trim());
            }
        });

        const firebaseConfig = {
            apiKey: "AIzaSyDCeJPDQUNi-KmJ9DhkTRIu-9t2PGZCpt0",
            authDomain: "mansungcoin-c6e06.firebaseapp.com",
            projectId: "mansungcoin-c6e06",
            storageBucket: "mansungcoin-c6e06.firebasestorage.app",
            messagingSenderId: "704809284946",
            appId: "1:704809284946:web:3e71d98f38810577e1768b"
        };

        const app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        storage = getStorage(app);
        const studentLoginTab = document.getElementById('book-student-login-tab');
        const teacherLoginTab = document.getElementById('book-teacher-login-tab');
        const studentLoginContent = document.getElementById('book-student-login-content');
        const teacherLoginContent = document.getElementById('book-teacher-login-content');

        function switchLoginTab(tab) {
            if (tab === 'student') {
                studentLoginTab.classList.add('active');
                teacherLoginTab.classList.remove('active');
                studentLoginContent.classList.add('active');
                teacherLoginContent.classList.remove('active');
            } else {
                teacherLoginTab.classList.add('active');
                studentLoginTab.classList.remove('active');
                teacherLoginContent.classList.add('active');
                studentLoginContent.classList.remove('active');
            }
        }

        studentLoginTab.addEventListener('click', () => switchLoginTab('student'));
        teacherLoginTab.addEventListener('click', () => switchLoginTab('teacher'));
        switchLoginTab('student');

        const studentRegisterView = document.getElementById('book-student-register-view');
        const teacherRegisterView = document.getElementById('book-teacher-register-view');
        const showStudentRegisterBtn = document.getElementById('book-show-student-register-btn');
        const showTeacherRegisterBtn = document.getElementById('book-show-teacher-register-btn');
        const backToLoginBtn = document.getElementById('book-back-to-login-btn');
        const teacherBackToLoginBtn = document.getElementById('book-teacher-back-to-login-btn');

        function showLoginView() {
            document.getElementById('book-login-view').classList.remove('hidden');
            studentRegisterView.classList.add('hidden');
            teacherRegisterView.classList.add('hidden');
        }

        showStudentRegisterBtn.addEventListener('click', () => {
            document.getElementById('book-login-view').classList.add('hidden');
            teacherRegisterView.classList.add('hidden');
            studentRegisterView.classList.remove('hidden');
        });

        showTeacherRegisterBtn.addEventListener('click', () => {
            document.getElementById('book-login-view').classList.add('hidden');
            studentRegisterView.classList.add('hidden');
            teacherRegisterView.classList.remove('hidden');
        });

        backToLoginBtn.addEventListener('click', showLoginView);
        teacherBackToLoginBtn.addEventListener('click', showLoginView);

        document.getElementById('book-student-register-btn').addEventListener('click', async () => {
            const name = document.getElementById('book-student-name').value.trim();
            if (!name) { alert('이름을 입력해주세요.'); return; }

            try {
                const counterRef = doc(db, 'metadata', 'counters');
                const newCode = await runTransaction(db, async (transaction) => {
                    const counterDoc = await transaction.get(counterRef);
                    let nextCode = 1;
                    if (counterDoc.exists() && counterDoc.data().lastUserCode) {
                        nextCode = counterDoc.data().lastUserCode + 1;
                    }
                    transaction.set(counterRef, { lastUserCode: nextCode }, { merge: true });
                    return nextCode;
                });

                const email = `${newCode}@abc.com`;
                const password = `${newCode}qwerty`;
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);

                await setDoc(doc(db, 'users', userCredential.user.uid), {
                    uid: userCredential.user.uid,
                    name: name,
                    email: email,
                    userCode: newCode,
                    role: 'student',
                    coins: 0,
                    balance: 0,
                    portfolio: {},
                    createdAt: serverTimestamp()
                });

                await addDoc(collection(db, 'signupLog'), {
                    name: name,
                    userCode: newCode,
                    role: 'student',
                    signedUpAt: serverTimestamp()
                });

                alert(`환영합니다, ${name} 학생! 고유 코드는 ${newCode} 입니다.`);
                studentRegisterView.classList.add('hidden');
                document.getElementById('book-login-view').classList.remove('hidden');
                switchLoginTab('student');
            } catch (e) {
                console.error('Error adding document: ', e);
                alert('학생 등록 중 문제가 발생했습니다.');
            }
        });

        document.getElementById('book-teacher-register-btn').addEventListener('click', async () => {
            const name = document.getElementById('book-teacher-register-name').value.trim();
            const email = document.getElementById('book-teacher-register-email').value.trim();
            const password = document.getElementById('book-teacher-register-password').value;

            if (!name || !email || !password) {
                alert('이름, 이메일, 비밀번호를 모두 입력해주세요.');
                return;
            }

            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                await setDoc(doc(db, 'users', userCredential.user.uid), {
                    uid: userCredential.user.uid,
                    name,
                    email,
                    role: 'teacher',
                    userCode: null,
                    coins: 0,
                    balance: 0,
                    portfolio: {},
                    aeduTokens: 0,
                    aeduExperience: 0,
                    aeduLevel: 1,
                    warningTokens: 0,
                    createdAt: serverTimestamp()
                }, { merge: true });

                await addDoc(collection(db, 'signupLog'), {
                    name,
                    email,
                    role: 'teacher',
                    signedUpAt: serverTimestamp()
                });

                alert(`환영합니다, ${name} 선생님! 이제 로그인해보세요.`);
                document.getElementById('book-teacher-register-name').value = '';
                document.getElementById('book-teacher-register-email').value = '';
                document.getElementById('book-teacher-register-password').value = '';
                teacherRegisterView.classList.add('hidden');
                document.getElementById('book-login-view').classList.remove('hidden');
                switchLoginTab('teacher');
            } catch (error) {
                console.error('Teacher registration error:', error);
                let message = '교사 회원가입 중 문제가 발생했습니다. 잠시 후 다시 시도해주세요.';
                if (error.code === 'auth/email-already-in-use') {
                    message = '이미 사용 중인 이메일입니다. 다른 이메일을 사용해주세요.';
                } else if (error.code === 'auth/invalid-email') {
                    message = '유효한 이메일 주소를 입력해주세요.';
                } else if (error.code === 'auth/weak-password') {
                    message = '비밀번호는 6자 이상이어야 합니다.';
                }
                alert(message);
            }
        });

        const addBookModal = document.getElementById('add-book-modal');
        const cancelAddBookBtn = document.getElementById('cancel-add-book');
        const confirmAddBookBtn = document.getElementById('confirm-add-book');
        const newBookTitleInput = document.getElementById('new-book-title');
        const bookLogoutBtn = document.getElementById('book-logout-btn');
        const myInfoBtn = document.getElementById('my-info-btn');
        const myInfoModal = document.getElementById('my-info-modal');
        const myInfoNameInput = document.getElementById('my-info-name');
        const myInfoSaveBtn = document.getElementById('my-info-save-btn');
        const closeMyInfoModalBtn = document.getElementById('close-my-info-modal');
        const myBooksTab = document.getElementById('my-books-tab');
        const libraryTab = document.getElementById('library-tab');
        const myBookListEl = document.getElementById('my-book-list');
        const libraryBookListEl = document.getElementById('library-book-list');
        const libraryControls = document.getElementById('library-controls');
        const librarySearchInput = document.getElementById('library-search-input');
        const libraryClassOnlyBtn = document.getElementById('library-class-only-btn');
        const libraryShowAllBtn = document.getElementById('library-show-all-btn');
        const bookLikeBtn = document.getElementById('book-like-btn');
        const addCommentBtn = document.getElementById('add-comment-btn');

        myBooksTab.addEventListener('click', () => {
            myBooksTab.classList.add('border-orange-500', 'text-orange-500');
            libraryTab.classList.remove('border-orange-500', 'text-orange-500');
            myBookListEl.classList.remove('hidden');
            libraryBookListEl.classList.add('hidden');
            if (libraryControls) libraryControls.classList.add('hidden');
            loadUserBooks();
        });

        libraryTab.addEventListener('click', () => {
            libraryTab.classList.add('border-orange-500', 'text-orange-500');
            myBooksTab.classList.remove('border-orange-500', 'text-orange-500');
            libraryBookListEl.classList.remove('hidden');
            myBookListEl.classList.add('hidden');
            if (libraryControls) libraryControls.classList.remove('hidden');
            loadLibraryBooks();
        });

        if (librarySearchInput) {
            librarySearchInput.addEventListener('input', () => renderLibraryBooks());
        }

        if (libraryClassOnlyBtn && libraryShowAllBtn) {
            libraryClassOnlyBtn.addEventListener('click', () => {
                libraryShowClassOnly = true;
                updateLibraryTeacherControls();
                renderLibraryBooks();
            });
            libraryShowAllBtn.addEventListener('click', () => {
                libraryShowClassOnly = false;
                updateLibraryTeacherControls();
                renderLibraryBooks();
            });
        }

        bookLikeBtn.addEventListener('click', likeBook);
        addCommentBtn.addEventListener('click', addComment);

        bookLogoutBtn.addEventListener('click', async () => {
            try {
                await signOut(auth);
            } catch (error) {
                console.error('Error signing out:', error);
            }
        });

        myInfoBtn.addEventListener('click', () => {
            if (!bookAuthorUid) return;
            myInfoNameInput.value = window.authorName || '';
            myInfoModal.classList.remove('hidden');
            myInfoNameInput.focus();
        });
        closeMyInfoModalBtn.addEventListener('click', () => myInfoModal.classList.add('hidden'));
        myInfoSaveBtn.addEventListener('click', async () => {
            const newName = myInfoNameInput.value.trim();
            if (!newName) { showNotification('이름을 입력하세요'); return; }
            try {
                await updateDoc(doc(db, 'users', bookAuthorUid), { name: newName });
                showNotification('이름이 변경되었습니다.');
                myInfoModal.classList.add('hidden');
                await updateUserInfo();
            } catch (err) {
                console.error('Error updating name:', err);
                showNotification('이름 변경 실패: ' + err.message);
            }
        });

        cancelAddBookBtn.addEventListener('click', () => {
            addBookModal.classList.add('hidden');
        });

        confirmAddBookBtn.addEventListener('click', async () => {
            if (!bookAuthorUid) return;
            const title = newBookTitleInput.value.trim();
            if (!title) { alert('책 제목을 입력하세요'); return; }

            try {
                const userRef = doc(db, 'users', bookAuthorUid);
                const userDoc = await getDoc(userRef);
                const tokens = Number(userDoc.data()?.aeduTokens) || 0;
                if (tokens < 1) { alert('에이두 토큰이 부족합니다.'); return; }
                await updateDoc(userRef, { aeduTokens: increment(-1) });
                await updateUserInfo();
                const newBookCode = `book${Date.now()}`;
                const authorNameForBook = window.authorName || window.bookAuthorName || '';
                window.bookAuthorName = authorNameForBook;
                await setDoc(doc(db, 'Book', newBookCode), {
                    author: authorNameForBook,
                    authorId: bookAuthorUid,
                    owner: bookAuthorUid,
                    createdAt: serverTimestamp(),
                    title,
                    isPublic: false
                });
                await addDoc(collection(db, `users/${bookAuthorUid}/myBooks`), {
                    bookId: newBookCode,
                    title,
                    createdAt: serverTimestamp()
                });
                await loadUserBooks();
                addBookModal.classList.add('hidden');
            } catch (error) {
                console.error('Error adding book:', error);
                alert('책을 추가하지 못했습니다. 다시 시도해주세요.');
            }
        });

        // --- My Class and Token Features ---
        const myClassBtn = document.getElementById('my-class-btn');
        const myClassModal = document.getElementById('my-class-modal');
        const myClassStudentList = document.getElementById('my-class-student-list');
        const myClassList = document.getElementById('my-class-list');
        const addClassBtn = document.getElementById('add-class-btn');
        const addMyClassStudentBtn = document.getElementById('add-my-class-student-btn');
        const closeMyClassModalBtn = document.getElementById('close-my-class-modal');

        const addClassModal = document.getElementById('add-class-modal');
        const closeAddClassModalBtn = document.getElementById('close-add-class-modal');
        const cancelAddClassBtn = document.getElementById('cancel-add-class-btn');
        const confirmAddClassBtn = document.getElementById('confirm-add-class-btn');
        const newClassNameInput = document.getElementById('new-class-name');

        const classAddStudentsModal = document.getElementById('class-add-students-modal');
        const classAddStudentsClassName = document.getElementById('class-add-students-class-name');
        const classStudentList = document.getElementById('class-student-list');
        const classStudentSearch = document.getElementById('class-student-search');
        const classAddStudentsConfirmBtn = document.getElementById('class-add-students-confirm-btn');
        const closeClassAddStudentsBtn = document.getElementById('close-class-add-students-btn');

        const tokenGiveBtn = document.getElementById('token-give-btn');
        const tokenModal = document.getElementById('token-modal');
        const tokenUserList = document.getElementById('token-user-list');
        const tokenSelectClass = document.getElementById('token-select-class');
        const tokenUserSearch = document.getElementById('token-user-search');
        const tokenSelectClassLabel = tokenSelectClass.parentElement;
        const tokenAmountInput = document.getElementById('token-amount');
        const tokenDistributeConfirm = document.getElementById('token-distribute-confirm');
        const closeTokenModalBtn = document.getElementById('close-token-modal');

        myClassBtn.addEventListener('click', openMyClassModal);
        closeMyClassModalBtn.addEventListener('click', () => {
            myClassModal.classList.add('hidden');
            closeAddClassModal();
            classAddStudentsModal.classList.add('hidden');
            if (classAddStudentsClassName) classAddStudentsClassName.textContent = '';
        });
        if (addClassBtn) addClassBtn.addEventListener('click', openAddClassModal);
        if (closeAddClassModalBtn) closeAddClassModalBtn.addEventListener('click', closeAddClassModal);
        if (cancelAddClassBtn) cancelAddClassBtn.addEventListener('click', closeAddClassModal);
        if (confirmAddClassBtn) confirmAddClassBtn.addEventListener('click', confirmAddClass);
        if (addMyClassStudentBtn) addMyClassStudentBtn.addEventListener('click', openAddStudentsModal);
        if (closeClassAddStudentsBtn) closeClassAddStudentsBtn.addEventListener('click', () => {
            classAddStudentsModal.classList.add('hidden');
            if (classAddStudentsClassName) classAddStudentsClassName.textContent = '';
        });
        if (classAddStudentsConfirmBtn) classAddStudentsConfirmBtn.addEventListener('click', confirmAddStudents);

        tokenGiveBtn.addEventListener('click', () => openTokenModal());
        closeTokenModalBtn.addEventListener('click', () => tokenModal.classList.add('hidden'));
        tokenSelectClass.addEventListener('change', () => {
            document.querySelectorAll('#token-user-list input[data-inclass="1"]').forEach(cb => cb.checked = tokenSelectClass.checked);
        });
        tokenDistributeConfirm.addEventListener('click', distributeTokens);

        async function openMyClassModal() {
            myClassModal.classList.remove('hidden');
            myClassStudentList.innerHTML = '로딩 중...';
            await loadTeacherClassStudents({ keepSelection: true, skipLibraryRender: true });
            renderClassList();
            await renderSelectedClassStudents();
        }

        function renderClassList() {
            if (!myClassList) return;
            myClassList.innerHTML = '';
            if (!teacherClasses.length) {
                const emptyEl = document.createElement('div');
                emptyEl.className = 'text-sm text-gray-500';
                emptyEl.textContent = '생성된 학급이 없습니다. 학급을 추가해 주세요.';
                myClassList.appendChild(emptyEl);
                setAddStudentButtonState(false);
                updateAddClassButtonState();
                return;
            }

            teacherClasses.forEach(cls => {
                const btn = document.createElement('button');
                const isSelected = cls.id === selectedClassId;
                btn.className = `px-3 py-1 rounded-full border text-sm ${isSelected ? 'bg-amber-500 text-white border-amber-500' : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-100'}`;
                btn.textContent = cls.name || '이름 없는 학급';
                btn.addEventListener('click', async () => {
                    selectedClassId = cls.id;
                    renderClassList();
                    await renderSelectedClassStudents();
                });
                myClassList.appendChild(btn);
            });

            setAddStudentButtonState(Boolean(selectedClassId));
            updateAddClassButtonState();
        }

        function setAddStudentButtonState(enabled) {
            if (!addMyClassStudentBtn) return;
            addMyClassStudentBtn.disabled = !enabled;
            addMyClassStudentBtn.classList.toggle('opacity-50', !enabled);
            addMyClassStudentBtn.classList.toggle('cursor-not-allowed', !enabled);
        }

        function updateAddClassButtonState() {
            if (!addClassBtn) return;
            const canAdd = teacherClasses.length === 0;
            addClassBtn.disabled = !canAdd;
            addClassBtn.classList.toggle('opacity-50', !canAdd);
            addClassBtn.classList.toggle('cursor-not-allowed', !canAdd);
        }

        async function renderSelectedClassStudents() {
            if (!selectedClassId) {
                myClassStudentList.innerHTML = '<li class="text-sm text-gray-500">학급을 먼저 선택하세요.</li>';
                setAddStudentButtonState(false);
                return;
            }
            setAddStudentButtonState(true);
            myClassStudentList.innerHTML = '로딩 중...';
            const selectedClass = teacherClasses.find(cls => cls.id === selectedClassId);
            if (!selectedClass) {
                myClassStudentList.innerHTML = '<li class="text-sm text-gray-500">학급 정보를 찾을 수 없습니다.</li>';
                return;
            }
            const students = Array.isArray(selectedClass.students) ? selectedClass.students : [];
            if (students.length === 0) {
                myClassStudentList.innerHTML = '<li class="text-sm text-gray-500">학생 없음</li>';
                return;
            }
            try {
                const studentItems = await Promise.all(students.map(async (sid) => {
                    try {
                        const sdoc = await getDoc(doc(db, 'users', sid));
                        if (!sdoc.exists()) return null;
                        const sdata = sdoc.data();
                        return `<li class="flex justify-between items-center py-1 border-b border-dotted border-gray-300 last:border-b-0"><span>${sdata.name} (코드: ${sdata.userCode})</span><button class="give-token-btn bg-purple-500 text-white px-2 py-1 rounded text-xs" data-uid="${sdoc.id}">토큰 지급</button></li>`;
                    } catch (error) {
                        console.error('Failed to load student info:', error);
                        return null;
                    }
                }));
                const html = studentItems.filter(Boolean).join('');
                myClassStudentList.innerHTML = html || '<li class="text-sm text-gray-500">학생 정보를 불러올 수 없습니다.</li>';
                myClassStudentList.querySelectorAll('.give-token-btn').forEach(btn => {
                    btn.addEventListener('click', () => openTokenModal([btn.dataset.uid]));
                });
            } catch (err) {
                myClassStudentList.innerHTML = `<li class="text-red-500">오류: ${err.message}</li>`;
            }
        }

        function openAddClassModal() {
            if (!bookAuthorUid) { showNotification('로그인 후 이용해주세요.'); return; }
            if (!addClassModal) return;
            if (teacherClasses.length > 0) {
                showNotification('이미 생성된 학급이 있습니다.');
                return;
            }
            newClassNameInput.value = '';
            addClassModal.classList.remove('hidden');
            setTimeout(() => newClassNameInput.focus(), 0);
        }

        function closeAddClassModal() {
            if (!addClassModal) return;
            addClassModal.classList.add('hidden');
            newClassNameInput.value = '';
        }

        async function confirmAddClass() {
            if (!bookAuthorUid) { showNotification('로그인 후 이용해주세요.'); return; }
            const className = newClassNameInput.value.trim();
            if (!className) { showNotification('학급 이름을 입력하세요.'); return; }
            if (teacherClasses.length > 0) {
                showNotification('이미 생성된 학급이 있습니다.');
                closeAddClassModal();
                return;
            }
            const originalText = confirmAddClassBtn.textContent;
            confirmAddClassBtn.disabled = true;
            confirmAddClassBtn.textContent = '생성 중...';
            try {
                const newClassId = await createTeacherClass(db, bookAuthorUid, className);
                selectedClassId = newClassId;
                closeAddClassModal();
                await loadTeacherClassStudents({ keepSelection: true });
                renderClassList();
                await renderSelectedClassStudents();
                showNotification('새 학급이 추가되었습니다.');
            } catch (error) {
                console.error('Failed to add class:', error);
                showNotification(`학급 추가 실패: ${error.message}`);
            } finally {
                confirmAddClassBtn.disabled = false;
                confirmAddClassBtn.textContent = originalText;
            }
        }

        async function openAddStudentsModal() {
            if (!selectedClassId) { showNotification('학급을 먼저 선택하세요.'); return; }
            await loadTeacherClassStudents({ keepSelection: true, skipLibraryRender: true });
            renderClassList();
            const selectedClass = teacherClasses.find(cls => cls.id === selectedClassId);
            if (!selectedClass) { showNotification('선택한 학급 정보를 찾을 수 없습니다.'); return; }
            if (classAddStudentsClassName) {
                classAddStudentsClassName.textContent = selectedClass.name ? `(${selectedClass.name})` : '';
            }
            classAddStudentsModal.classList.remove('hidden');
            classStudentList.innerHTML = '학생 목록 로딩 중...';
            try {
                const usersSnapshot = await getDocs(query(collection(db, 'users'), where('role', '==', 'student')));
                const existingStudents = Array.isArray(selectedClass.students) ? selectedClass.students : [];
                classStudentList.innerHTML = usersSnapshot.docs.map(d => {
                    const s = { id: d.id, ...d.data() };
                    const checked = existingStudents.includes(s.id) ? 'checked disabled' : '';
                    return `<label class="flex items-center space-x-2 p-1"><input type="checkbox" data-studentid="${s.id}" ${checked}><span>${s.name} (코드: ${s.userCode})</span></label>`;
                }).join('');
            } catch (err) {
                classStudentList.innerHTML = `<p class="text-red-500 text-center">학생 목록을 불러오지 못했습니다.</p>`;
            }
            classStudentSearch.value = '';
            classStudentSearch.oninput = e => {
                const term = e.target.value.toLowerCase();
                document.querySelectorAll('#class-student-list label').forEach(lbl => {
                    lbl.style.display = lbl.textContent.toLowerCase().includes(term) ? 'flex' : 'none';
                });
            };
        }

        async function confirmAddStudents() {
            if (!selectedClassId) { showNotification('학급을 먼저 선택하세요.'); return; }
            const selectedClass = teacherClasses.find(cls => cls.id === selectedClassId);
            if (!selectedClass) { showNotification('선택한 학급 정보를 찾을 수 없습니다.'); return; }
            const selected = Array.from(document.querySelectorAll('#class-student-list input:checked:not(:disabled)')).map(i => i.dataset.studentid);
            if (selected.length === 0) {
                showNotification('추가할 학생을 선택하세요.');
                return;
            }
            try {
                await addStudentsToTeacherClass(db, bookAuthorUid, selected);
                showNotification('학생이 학급에 추가되었습니다.');
            } catch (error) {
                console.error('Failed to add students to class:', error);
                showNotification(`학생 추가 실패: ${error.message}`);
            }
            classAddStudentsModal.classList.add('hidden');
            if (classAddStudentsClassName) classAddStudentsClassName.textContent = '';
            await loadTeacherClassStudents({ keepSelection: true });
            renderClassList();
            await renderSelectedClassStudents();
        }

        async function openTokenModal(targetUserIds = null) {
            tokenModal.classList.remove('hidden');
            tokenUserList.innerHTML = '불러오는 중...';
            const restrict = Array.isArray(targetUserIds) && targetUserIds.length > 0;
            tokenSelectClassLabel.classList.toggle('hidden', restrict);
            tokenUserSearch.classList.toggle('hidden', restrict);
            tokenSelectClass.checked = false;
            try {
                await loadTeacherClassStudents({ keepSelection: true, skipLibraryRender: true });
                const classStudentIds = currentClassStudents || [];
                const usersSnap = await getDocs(collection(db, 'users'));
                tokenUserList.innerHTML = usersSnap.docs.map(d => {
                    const u = { id: d.id, ...d.data() };
                    const inClass = classStudentIds.includes(u.id) ? '1' : '0';
                    const checked = restrict && targetUserIds.includes(u.id) ? 'checked' : '';
                    const display = !restrict || targetUserIds.includes(u.id) ? 'flex' : 'none';
                    const code = u.userCode || '';
                    return `<label class="flex items-center space-x-2 p-1" data-name="${u.name}" data-code="${code}" style="display:${display}"><input type="checkbox" class="token-user-checkbox" data-inclass="${inClass}" value="${u.id}" ${checked}><span>${u.name} (코드: ${code})</span></label>`;
                }).join('');
            } catch (err) {
                tokenUserList.innerHTML = `<p class="text-red-500 text-center">목록을 불러오지 못했습니다.</p>`;
            }
            tokenUserSearch.value = '';
            tokenUserSearch.oninput = e => {
                const term = e.target.value.toLowerCase();
                document.querySelectorAll('#token-user-list label').forEach(lbl => {
                    const name = (lbl.dataset.name || '').toLowerCase();
                    const code = String(lbl.dataset.code || '').toLowerCase();
                    lbl.style.display = name.includes(term) || code.includes(term) ? 'flex' : 'none';
                });
            };
        }

        async function distributeTokens() {
            const amount = Number(tokenAmountInput.value);
            if (isNaN(amount) || amount <= 0) { showNotification('토큰 양을 입력하세요'); return; }
            const selected = Array.from(document.querySelectorAll('.token-user-checkbox:checked')).map(i => i.value);
            if (selected.length === 0) { showNotification('학생을 선택하세요'); return; }
            try {
                for (const uid of selected) {
                    await updateDoc(doc(db, 'users', uid), { aeduTokens: increment(amount) });
                }
                showNotification('토큰 지급이 완료되었습니다.');
            } catch (err) {
                showNotification(`토큰 지급 실패: ${err.message}`);
            }
            tokenAmountInput.value = '';
            tokenModal.classList.add('hidden');
        }

        document.getElementById('back-to-list-btn').addEventListener('click', () => {
            document.getElementById('book-viewer-page').classList.add('hidden');
            document.getElementById('book-list-section').classList.remove('hidden');
        });

        document.getElementById('book-student-login-btn').addEventListener('click', async () => {
            const codeInput = document.getElementById('book-student-code').value.trim();
            const normalizedCode = codeInput.replace(/[\uFF10-\uFF19]/g, m => String.fromCharCode(m.charCodeAt(0) - 0xFEE0));
            if (!normalizedCode || !/^\d+$/.test(normalizedCode)) { alert('유효한 숫자 코드를 입력해주세요.'); return; }
            const codeAsInt = parseInt(normalizedCode, 10);
            const email = `${codeAsInt}@abc.com`;
            const password = `${codeAsInt}qwerty`;
            try { await signInWithEmailAndPassword(auth, email, password); } catch (_) { alert('로그인 실패'); }
        });

        document.getElementById('book-teacher-login-btn').addEventListener('click', async () => {
            const email = document.getElementById('book-teacher-email').value;
            const password = document.getElementById('book-teacher-password').value;
            if (!email || !password) { alert('이메일과 비밀번호를 모두 입력해주세요.'); return; }
            try { await signInWithEmailAndPassword(auth, email, password); } catch (_) { alert('로그인 실패'); }
        });

        document.getElementById('book-teacher-google-login-btn').addEventListener('click', async () => {
            const provider = new GoogleAuthProvider();
            try { await signInWithPopup(auth, provider); } catch (_) { alert('로그인 실패'); }
        });

        onAuthStateChanged(auth, async (user) => {
            const loginView = document.getElementById('book-login-view');
            const contentView = document.getElementById('book-content');
            const viewerPage = document.getElementById('book-viewer-page');
            const listSection = document.getElementById('book-list-section');
            if (user) {
                loginView.classList.add('hidden');
                studentRegisterView.classList.add('hidden');
                teacherRegisterView.classList.add('hidden');
                contentView.classList.remove('hidden');
                viewerPage.classList.add('hidden');
                listSection.classList.remove('hidden');
                bookAuthorUid = user.uid;
                libraryShowClassOnly = false;
                const ensuredDoc = await ensureBookUserDocument(user);
                const ensuredData = ensuredDoc && typeof ensuredDoc.data === 'function' ? ensuredDoc.data() : null;
                await updateUserInfo(ensuredData);
                await loadUserBooks();
                await loadLibraryBooks();
                if (initialBookId && !hasAttemptedInitialBookLoad) {
                    hasAttemptedInitialBookLoad = true;
                    try {
                        await loadBook(initialBookId);
                        if (forceViewerMode) {
                            setViewMode(true);
                        }
                    } catch (error) {
                        console.error('Failed to open initial book:', error);
                        showNotification('책을 불러오지 못했습니다.');
                    }
                }
            } else {
                loginView.classList.remove('hidden');
                studentRegisterView.classList.add('hidden');
                teacherRegisterView.classList.add('hidden');
                contentView.classList.add('hidden');
                window.currentUserRole = 'student';
                bookAuthorUid = null;
                currentClassStudents = [];
                teacherClasses = [];
                selectedClassId = null;
                libraryShowClassOnly = false;
                if (libraryControls) libraryControls.classList.add('hidden');
                if (librarySearchInput) librarySearchInput.value = '';
                libraryBooksCache = [];
                renderLibraryBooks();
                updateLibraryTeacherControls();
            }
        });

        window.addCharacterPage = addCharacterPage;
        window.addManualPage = addManualPage;
        window.deleteCurrentPage = deleteCurrentPage;
        window.changeBookPage = changeBookPage;
        window.completeManualBook = completeManualBook;
        window.completeManualBookGPT = completeManualBookGPT;
        window.saveBookDraft = saveBookDraft;
        window.downloadBookAsPDF = downloadBookAsPDF;
        window.registerToLibrary = registerToLibrary;
        window.enableEditMode = enableEditMode;
    </script>
</body>
</html>

